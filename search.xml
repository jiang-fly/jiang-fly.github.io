<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Integer的valueOf(int)方法</title>
    <url>/2020/08/14/Integer/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<blockquote>
<p>装箱就是自动将基本数据类型转换为包装器类型（int–&gt;Integer）；调用方法：Integer的<br>valueOf(int) 方法<br>拆箱就是自动将包装器类型转换为基本数据类型（Integer–&gt;int）。调用方法：Integer的intValue方法</p>
</blockquote>
<p><strong>先来看一段代码</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IntegerDemo01</span> <span class="token punctuation">{</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     Integer i2 <span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>
     Integer i3 <span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>
     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i2<span class="token operator">==</span>i3<span class="token punctuation">)</span><span class="token punctuation">;</span>

     Integer i4 <span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span>
     Integer i5 <span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">;</span>
     System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3<span class="token operator">==</span>i4<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>以上输出是true 还是false呢？<br>其中第一个是true ，第二个是false。初学者就会对这个答案产生疑问。为啥会出现这个情况呢？<br>先通过反编译 查看一下到底编译器是怎么处理这行代码的？</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>PrintStream<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IntegerDemo01</span>
 <span class="token punctuation">{</span>

  <span class="token keyword">public</span> <span class="token function">IntegerDemo01</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token punctuation">}</span>

  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
 <span class="token punctuation">{</span>
    Integer i2 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Integer i3 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i2 <span class="token operator">==</span> i3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Integer i4 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Integer i5 <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>从上面代码可以得知，编译器引用变量的定义和初始化中使用到了Integer.valueOf()方法，这个valueOf()是干嘛用的呢？</p>
</blockquote>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Integer <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">>=</span> IntegerCache<span class="token punctuation">.</span>low <span class="token operator">&amp;&amp;</span> i <span class="token operator">&lt;=</span> IntegerCache<span class="token punctuation">.</span>high<span class="token punctuation">)</span>
   <span class="token comment" spellcheck="true">//如果数值在-128~127之间的 </span>
<span class="token keyword">return</span> IntegerCache<span class="token punctuation">.</span>cache<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">-</span>IntegerCache<span class="token punctuation">.</span>low<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true">//返回 </span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span></code></pre>
<blockquote>
<p><strong>来看这段代码的描述</strong></p>
<ul>
<li>Returns an {@code Integer} instance representing the specified<br>{@code int} value.,<br>返回了这个Integer的含有指定的值的实例</li>
<li>as this method is likely to yield significantly better space and time performance by</li>
<li>显着更好的空间和时间性能</li>
<li>caching frequently requested values.</li>
</ul>
</blockquote>
<p><strong>解释：</strong><br><strong>1.这个方法返回了一个带有值的实例，<br>2.然后返回了一个从-128~127的值的缓存数组，用于缓存在这个范围内所有创建的实例对象。<br>3.如果之前有存在就直接拿来用，不存在的话就新建new 一个Integer对象。</strong></p>
<h2 id="String类型的问题"><a href="#String类型的问题" class="headerlink" title="String类型的问题"></a>String类型的问题</h2><blockquote>
<p>有人会联想到String类型，因为String的实例有时候也是这么赋值的。那么编译器在背后有没有进行转化呢？看一下代码？</p>
</blockquote>
<pre class=" language-java"><code class="language-java"> String str <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
    String str2 <span class="token operator">=</span><span class="token string">"abc"</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token operator">==</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    String str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    String str4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>str3<span class="token operator">==</span>str4<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>&ensp;&ensp;&ensp;&ensp;<strong>如上的结果第一个是true ，第二个是false。</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>第一个是在常量池中去查找是否有没有这个abc这个值，有的话，直接进行引用。没有的话，再在常量池中创建。所以第一个的引用变量他们的地址都相同的，因此为true。</strong></p>
<p>&ensp;&ensp;&ensp;&ensp;<strong>第二个用到了new，这个单词告诉了编译器 直接在堆内存中给我开辟了一个空间，不管之前是否有存在。因此，尽管值也一样，但是它们引用的地址是不一样的。因此为false。</strong></p>
<blockquote>
<p>再来看一下编译器是否有将String的实例构建进行某些转换？发现没有任何操作，没有偷着我们干了什么事。</p>
</blockquote>
<pre class=" language-java"><code class="language-java">    String str <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
    String str2 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    String str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    String str4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>str3 <span class="token operator">==</span> str4<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<blockquote>
<p>建议，如果要判断包装类的对象是否相等，最好用equals()方法.</p>
</blockquote>
]]></content>
      <categories>
        <category>包装器类型</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Integer</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo与MarkDown</title>
    <url>/2020/08/08/MarkDown/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy84NTc0MTMwLTM3Nzc4OTA4YmU5ODFkZGQuUE5H?x-oss-process=image/format,png#pic_center" alt="Hexo与MarkDown"></p>
<blockquote>
<p>&emsp;&emsp;在hexo中的markdown语法稍有不同本文将列举我遇的例子，同时简述hexo的一些指令集，适用于初学者使用hexo+github搭建博客写作发布文章。</p>
</blockquote>
<h1 id="Hexo-指令"><a href="#Hexo-指令" class="headerlink" title="Hexo 指令"></a>Hexo 指令</h1><h2 id="hexo新建文章"><a href="#hexo新建文章" class="headerlink" title="hexo新建文章"></a>hexo新建文章</h2><p>&emsp;&emsp;hexo文件夹下右键点击Git Base here后键入$hexo new 布局 “文章名”</p>
<table>
<thead>
<tr>
<th>布局</th>
<th>路径</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>post    source</td>
<td>_post</td>
<td>新建一个文章</td>
</tr>
<tr>
<td>draft    source</td>
<td>_drafts</td>
<td>新建一个草稿文件</td>
</tr>
<tr>
<td>page</td>
<td>source</td>
<td>新建一个页面文件</td>
</tr>
</tbody></table>
<h2 id="hexo部署与调试"><a href="#hexo部署与调试" class="headerlink" title="hexo部署与调试"></a>hexo部署与调试</h2><pre><code>
$ hexo clean //清除静态页面缓存（清除 public 文件夹)         
$ hexo g     //在本地生成静态页面（生成 public 文件夹）        
$ hexo s     //启动本地服务 http://localhost:4000，进行预览调试           
$ hexo d     //远程部署，同步到 GitHub         

$ npm install hexo-deployer-git --save    //自动部署
$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d          //发布</code></pre><h1 id="MarkDown-与-文章编辑"><a href="#MarkDown-与-文章编辑" class="headerlink" title="MarkDown 与 文章编辑"></a>MarkDown 与 文章编辑</h1><h2 id="emsp-文章配置"><a href="#emsp-文章配置" class="headerlink" title="&emsp;文章配置"></a>&emsp;文章配置</h2><p>&emsp;&emsp;在hexo文件夹下右键点击Git Base here后键入$hexo new page “name”，source/_post 文件夹中生成name.md文件，打开后即可编辑，编辑格式如下：</p>
<pre><code>title: 文章名
date: 2017-10-31 20:38:17     //发表日期
updated: 2017-10-31 21:58:03  //更新日期
categories: Life              //文章分类
tags: [tag1,tag2]             //文章标签，多标签时使用英文逗号隔开
photos:                       //如果使用Fancybox（文章头部展示图片），如此设置  
                              //注意冒号后面有空格</code></pre><h1 id="MarkDown语法在hexo中"><a href="#MarkDown语法在hexo中" class="headerlink" title="MarkDown语法在hexo中"></a>MarkDown语法在hexo中</h1><blockquote>
<p>编辑器：<a href="https://www.jianshu.com/go-wild?ac=2&url=http://markdownpad.com/" target="_blank" rel="noopener">markdownPad 2.5</a></p>
</blockquote>
<p><strong>代码格式</strong><br><code>codes</code>   //单行代码放置于一对反引号中<br>          //4空格+codes亦可实现单行代码</p>
<pre class=" language-//代码块放置于3个反引号中间，回车即可换行"><code class="language-//代码块放置于3个反引号中间，回车即可换行">#include<stdio.h>
int main()
{
    printf("Hello World!\n");
    return 0;
}
</code></pre>
<p><strong>首行缩进</strong><br> &amp;ensp 相当于1个中文，2字节</p>
<p><strong>文章折叠</strong><br>在要显示的文字末尾添加如下代码实现文章在主页的折叠显示。</p>
<pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> more <span class="token operator">--</span><span class="token operator">></span></code></pre>
<p> <img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczAuYmRzdGF0aWMuY29tLzcwY0Z2SFNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTM3MjI5MTIwMzAsMzEwOTAwOTM5NCZmbT0yNiZncD0wLmpwZw?x-oss-process=image/format,png" alt="图片"></p>
]]></content>
      <categories>
        <category>MarkDown的使用</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>MarkDown</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx的笔记(基础)</title>
    <url>/2020/08/28/Nginx%20%E7%9A%84%E7%AC%94%E8%AE%B0(%E5%9F%BA%E7%A1%80%EF%BC%89/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<h2 id="一-Nginx-的简介"><a href="#一-Nginx-的简介" class="headerlink" title="一.Nginx 的简介"></a>一.Nginx 的简介</h2><h3 id="1、什么是-nginx"><a href="#1、什么是-nginx" class="headerlink" title="1、什么是 nginx"></a>1、什么是 nginx</h3><p>&emsp;&emsp;Nginx 是高性能的 HTTP 和反向代理的<font color=red>服务器</font>，处理高并发能力是十分强大的，能经受高负载的考验,有报告表明能支持高达 50,000 个并发连接数。</p>
<h3 id="2、正向代理"><a href="#2、正向代理" class="headerlink" title="2、正向代理"></a>2、正向代理</h3><p><strong>（1）需要在客户端配置代理服务器进行指定网站访问</strong><br><img src="https://img-blog.csdnimg.cn/20200827211439739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h3 id="3、反向代理"><a href="#3、反向代理" class="headerlink" title="3、反向代理"></a>3、反向代理</h3><p><strong>&emsp;&emsp;暴露的是代理服务器地址，隐藏了真实服务器 IP 地址。</strong><br><img src="https://img-blog.csdnimg.cn/20200827211534614.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h3 id="4、负载均衡"><a href="#4、负载均衡" class="headerlink" title="4、负载均衡"></a>4、负载均衡</h3><p>&emsp;&emsp;增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，<font color=orgrane>将负载分发到不同的服务器</font>，也就是我们所说的负载均衡</p>
<p><img src="https://img-blog.csdnimg.cn/20200827211813728.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h3 id="5、动静分离"><a href="#5、动静分离" class="headerlink" title="5、动静分离"></a>5、动静分离</h3><p><img src="https://img-blog.csdnimg.cn/20200827211854151.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h2 id="二-Nginx-的安装"><a href="#二-Nginx-的安装" class="headerlink" title="二.Nginx 的安装"></a>二.Nginx 的安装</h2><h3 id="1、准备工作"><a href="#1、准备工作" class="headerlink" title="1、准备工作"></a>1、准备工作</h3><p>（1）打开虚拟机，使用远程连接工具连接 linux 操作系统<br>（2）到 nginx 官网下载软件</p>
<blockquote>
<p><font color=red><a href="http://nginx.org/" target="_blank" rel="noopener">http://nginx.org/</a></font></p>
</blockquote>
<h3 id="2、开始进行-nginx-安装"><a href="#2、开始进行-nginx-安装" class="headerlink" title="2、开始进行 nginx 安装"></a>2、开始进行 nginx 安装</h3><p><strong>（1）<font color=red>安装 pcre 依赖</font></strong><br><font color=bluee><strong>第一步 联网下载 pcre 压缩文件依赖</font></strong><br>wget <a href="http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz" target="_blank" rel="noopener">http://downloads.sourceforge.net/project/pcre/pcre/8.37/pcre-8.37.tar.gz</a>   或者直接将压缩包拖入xshell当中。</p>
<p><img src="https://img-blog.csdnimg.cn/20200827212335792.png#pic_center" alt=""><br><strong><font color=blude>第二步 解压压缩文件</font></strong></p>
<p><strong>使用命令 tar –xvf pcre-8.37.tar.gz</strong></p>
<p><strong><font color=blude>第三步</font></strong><br><strong>./configure 完成后，回到 pcre 目录下执行 make，最后执行 make install</strong></p>
<p><strong>（2）<font color=red>安装 openssl 、zlib 、 gcc 依赖</font></strong><br><strong>yum -y install make zlib zlib-devel gcc-c++ libtool openssl openssl-devel</strong></p>
<p><strong>（3）<font color=red>安装 nginx</font></strong></p>
<ul>
<li><strong>使用命令解压</strong></li>
<li><strong>./configure</strong></li>
<li><strong>make &amp;&amp; make install</strong></li>
</ul>
<h3 id="3、若不能访问nginx"><a href="#3、若不能访问nginx" class="headerlink" title="3、若不能访问nginx"></a>3、若不能访问nginx</h3><p><strong>进入目录 <font color=red>cd /usr/local/nginx/sbin/nginx </font>启动服务</strong></p>
<p><strong>在 windows 系统中访问 linux 中 nginx，<font color=red>默认不能访问的</font>，因为防火墙问题<br>（1）<font color=red>关闭防火墙</font><br>（2）<font color=red>开放访问的端口号，80 端口</font></strong></p>
<p><strong><font color=red>查看开放的端口号</font></strong></p>
<pre class=" language-powershell"><code class="language-powershell">firewall<span class="token operator">-</span>cmd <span class="token operator">--</span>list<span class="token operator">-</span>all</code></pre>
<p><strong><font color=red>设置开放的端口号</font></strong></p>
<pre class=" language-powershell"><code class="language-powershell">firewall<span class="token operator">-</span>cmd <span class="token operator">--</span>add<span class="token operator">-</span>service=http –permanent
firewall<span class="token operator">-</span>cmd <span class="token operator">--</span>add<span class="token operator">-</span>port=80<span class="token operator">/</span>tcp <span class="token operator">--</span>permanent</code></pre>
<p><strong><font color=red>重启防火墙</font></strong></p>
<pre class=" language-powershell"><code class="language-powershell">firewall<span class="token operator">-</span>cmd –reload</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200827213812121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>成功访问Nginx的页面</strong><br><img src="https://img-blog.csdnimg.cn/20200827214024113.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h2 id="三-Nginx-的常用的命令"><a href="#三-Nginx-的常用的命令" class="headerlink" title="三.Nginx 的常用的命令"></a>三.Nginx 的常用的命令</h2><p><strong>进入 nginx 目录中</strong><br><strong><font color=red>cd /usr/local/nginx/sbin</font></strong></p>
<h3 id="1、查看-nginx-版本号"><a href="#1、查看-nginx-版本号" class="headerlink" title="1、查看 nginx 版本号"></a>1、查看 nginx 版本号</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token operator">-</span>v </code></pre>
<h3 id="2、启动-nginx"><a href="#2、启动-nginx" class="headerlink" title="2、启动 nginx"></a>2、启动 nginx</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token punctuation">.</span><span class="token operator">/</span>nginx</code></pre>
<h3 id="3、停止-nginx"><a href="#3、停止-nginx" class="headerlink" title="3、停止 nginx"></a>3、停止 nginx</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token operator">-</span>s stop</code></pre>
<h3 id="4、重新加载-nginx"><a href="#4、重新加载-nginx" class="headerlink" title="4、重新加载 nginx"></a>4、重新加载 nginx</h3><pre class=" language-powershell"><code class="language-powershell"><span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token operator">-</span>s reload</code></pre>
<h2 id="五-Nginx-的配置文件"><a href="#五-Nginx-的配置文件" class="headerlink" title="五.Nginx 的配置文件"></a>五.Nginx 的配置文件</h2><h3 id="1、nginx-配置文件位置"><a href="#1、nginx-配置文件位置" class="headerlink" title="1、nginx 配置文件位置"></a>1、nginx 配置文件位置</h3><pre class=" language-powershell"><code class="language-powershell">cd <span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>nginx<span class="token operator">/</span>conf<span class="token operator">/</span>nginx<span class="token punctuation">.</span>conf</code></pre>
<h3 id="2、配置文件中的内容"><a href="#2、配置文件中的内容" class="headerlink" title="2、配置文件中的内容"></a>2、配置文件中的内容</h3><p><strong>包含三部分内容</strong><br><strong>（1）<font color=red>全局块</font>：配置服务器整体运行的配置指令<br>比如 worker_processes 1;处理并发数的配置<br>（2）<font color=red>events 块</font>：影响 Nginx 服务器与用户的网络连接<br>比如 worker_connections 1024; 支持的最大连接数为 1024<br>（3）<font color=red>http 块</font><br>还包含两部分：<br>  &emsp;&emsp;<font color=red>http 全局块</font><br>&emsp;&emsp;<font color=red>server 块</font></strong></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>CentOS7</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx的笔记(实例)</title>
    <url>/2020/08/28/Nginx%E7%9A%84%E7%AC%94%E8%AE%B0%EF%BC%88%E5%AE%9E%E4%BE%8B%EF%BC%89/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<h1 id="一-Nginx-配置实例-反向代理实例-1"><a href="#一-Nginx-配置实例-反向代理实例-1" class="headerlink" title="一.Nginx 配置实例-反向代理实例 1"></a>一.Nginx 配置实例-反向代理实例 1</h1><p><img src="https://img-blog.csdnimg.cn/20200827220344427.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200827220943448.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200827221006190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200827221036538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><img src="https://img-blog.csdnimg.cn/20200827221107440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200827221135402.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h1 id="二-Nginx-配置实例-反向代理实例-2"><a href="#二-Nginx-配置实例-反向代理实例-2" class="headerlink" title="二.Nginx 配置实例-反向代理实例 2"></a>二.Nginx 配置实例-反向代理实例 2</h1><p><img src="https://img-blog.csdnimg.cn/2020082722130548.png#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/2020082722135657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/2020082722143231.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h1 id="三-Nginx-配置实例-负载均衡"><a href="#三-Nginx-配置实例-负载均衡" class="headerlink" title="三.Nginx 配置实例-负载均衡"></a>三.Nginx 配置实例-负载均衡</h1><p><img src="https://img-blog.csdnimg.cn/20200827221524666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200827221551607.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<p><strong>4、nginx 分配服务器策略</strong><br><strong><font color=red>第一种 轮询（默认）</font><br>&emsp;&emsp;每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。<br><font color=red>第二种 weight</font><br>&emsp;&emsp;weight 代表权重默认为 1,权重越高被分配的客户端越多<br><font color=red>第三种 ip_hash</font><br>&emsp;&emsp;每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器<br><font color=red>第四种 fair（第三方</font>）<br>&emsp;&emsp;按后端服务器的响应时间来分配请求，响应时间短的优先分配。</strong></p>
<h1 id="四-Nginx-配置实例-动静分离"><a href="#四-Nginx-配置实例-动静分离" class="headerlink" title="四.Nginx 配置实例-动静分离"></a>四.Nginx 配置实例-动静分离</h1><p><img src="https://img-blog.csdnimg.cn/20200827221953128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200827222025918.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200827222049455.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>重点是添加 location，<br>&emsp;&emsp;最后检查 Nginx 配置是否正确即可，然后测试动静分离是否成功，之需要删除后端 tomcat 服务器上的某个静态文件，查看是否能访问，如果可以访问说明静态资源 nginx 直接返回<br>了，不走后端 tomcat 服务器。</strong></p>
<h1 id="五-Nginx-配置高可用的集群"><a href="#五-Nginx-配置高可用的集群" class="headerlink" title="五.Nginx 配置高可用的集群"></a>五.Nginx 配置高可用的集群</h1><p><img src="https://img-blog.csdnimg.cn/20200828003753515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200828003850682.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200828004035956.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/2020082800400920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200828004101188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200828004301977.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200828004345163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200828004450936.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h1 id="六-Nginx-的原理"><a href="#六-Nginx-的原理" class="headerlink" title="六.Nginx 的原理"></a>六.Nginx 的原理</h1><p><img src="https://img-blog.csdnimg.cn/20200828004617577.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200828004637228.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200828004655739.png#pic_center" alt="">)<img src="https://img-blog.csdnimg.cn/20200828004758540.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>CentOS7</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis入门——Nosql概述</title>
    <url>/2020/08/29/Redis%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94Nosql%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<h2 id="一、Nosql概述"><a href="#一、Nosql概述" class="headerlink" title="一、Nosql概述"></a>一、Nosql概述</h2><h3 id="emsp-为什么使用Nosql"><a href="#emsp-为什么使用Nosql" class="headerlink" title="&emsp;为什么使用Nosql"></a>&emsp;为什么使用Nosql</h3><p>&emsp;&emsp;<strong>1、单机Mysql时代</strong><br><img src="https://img-blog.csdnimg.cn/20200828232619722.png#pic_center" alt=""><br>&emsp;&emsp;90年代,一个网站的访问量一般不会太大，单个数据库完全够用。随着用户增多，网站出现以下问题</p>
<p>&emsp;&emsp;<strong><font color=red>数据量增加到一定程度，单机数据库就放不下了</font></strong><br>&emsp;&emsp;<strong><font color=red>数据的索引（B+ Tree）,一个机器内存也存放不下</font></strong><br>&emsp;&emsp;<strong><font color=red>访问量变大后（读写混合），一台服务器承受不住。</font></strong></p>
<p>&emsp;&emsp;<strong>2、Memcached(缓存) + Mysql + 垂直拆分（读写分离）</strong></p>
<p>&emsp;&emsp;网站80%的情况都是在读，每次都要去查询数据库的话就十分的麻烦！所以说我们希望减轻数据库的压力，我们可以使用缓存来保证效率！<br><img src="https://img-blog.csdnimg.cn/20200828233042925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><font color=red>优化过程</font>经历了以下几个过程：</p>
<ul>
<li><strong>优化数据库的数据结构和索引(难度大)</strong></li>
<li><strong>文件缓存，通过IO流获取比每次都访问数据库效率略高，但是流量爆炸式增长时候，IO流也承受不了</strong></li>
<li><strong>MemCache,当时最热门的技术，通过在数据库和数据库访问层之间加上一层缓存，第一次访问时查询数据库，将结果保存到缓存，后续的查询先检查缓存，若有直接拿去使用，效率显著提升。</strong></li>
</ul>
<p>&emsp;&emsp;<strong>3、分库分表 + 水平拆分 + Mysql集群</strong><br><img src="https://img-blog.csdnimg.cn/20200828233409623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>&emsp;&emsp;<strong>4、如今最近的年代</strong></p>
<p>&emsp;&emsp;如今信息量井喷式增长，各种各样的数据出现（用户定位数据，图片数据等），大数据的背景下关系型数据(RDBMS）无法满足大量数据要求。<font color=red>Nosql数据库</font>就能轻松解决这些问题。</p>
<blockquote>
<p><strong><font color=red>目前一个基本的互联网项目</font></strong></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200828233708793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<blockquote>
<p><strong><font color=red>为什么要用NoSQL ？</font></strong></p>
</blockquote>
<p>&emsp;&emsp;<font color=blue>用户的个人信息</font>，<font color=blue>社交网络</font>，<font color=blue>地理位置</font>。<font color=blue>用户自己产生的数据</font>，<font color=blue>用户日志等等爆发式增长</font>！这时候我们就需要使用NoSQL数据库的，Nosql可以很好的处理以上的情况！</p>
<h3 id="emsp-什么是Nosql"><a href="#emsp-什么是Nosql" class="headerlink" title="&emsp;什么是Nosql"></a>&emsp;什么是Nosql</h3><blockquote>
<p>NoSQL = Not Only SQL（不仅仅是SQL）<br>Not Only Structured Query Language </p>
</blockquote>
<ul>
<li><font color=red>关系型数据库</font>：列+行，同一个表下数据的结构是一样的。</li>
<li><font color=red>非关系型数据库</font>：数据存储没有固定的格式，并且可以进行横向扩展。</li>
<li>NoSQL泛指非关系型数据库，随着web2.0互联网的诞生，传统的关系型数据库很难对付web2.0时代！尤其是超大规模的高并发的社区，暴露出来很多难以克服的问题，NoSQL在当今大数据环境下发展的十分迅速，<font color=red>Redis是发展最快的</font>。</li>
</ul>
<h3 id="emsp-Nosql特点"><a href="#emsp-Nosql特点" class="headerlink" title="&emsp;Nosql特点"></a>&emsp;Nosql特点</h3><ul>
<li><font color=red>方便扩展</font>（数据之间没有关系，很好扩展！）</li>
<li><font color=red>大数据量高性能</font>（Redis一秒可以写8万次，读11万次，NoSQL的缓存记录级，是一种细粒度的缓存，性能会比较高！）</li>
<li><font color=red> 数据类型是多样型的！</font>（不需要事先设计数据库，随取随用）</li>
<li><font color=red>传统的 RDBMS 和 NoSQL</font></li>
</ul>
<pre class=" language-bash"><code class="language-bash">传统的 RDBMS<span class="token punctuation">(</span>关系型数据库<span class="token punctuation">)</span>
- 结构化组织
- SQL
- 数据和关系都存在单独的表中 row col
- 操作，数据定义语言
- 严格的一致性
- 基础的事务
- <span class="token punctuation">..</span>.</code></pre>
<pre class=" language-bash"><code class="language-bash">Nosql
- 不仅仅是数据
- 没有固定的查询语言
- 键值对存储，列存储，文档存储，图形数据库（社交关系）
- 最终一致性
- CAP定理和BASE
- 高性能，高可用，高扩展
- <span class="token punctuation">..</span>.</code></pre>
<blockquote>
<p><font color=red><strong>了解：3V + 3高</strong></font></p>
</blockquote>
<p>大数据时代的3V ：<font color=red>主要是描述问题的</font></p>
<ul>
<li><p>海量Velume</p>
</li>
<li><p>多样Variety</p>
</li>
<li><p>实时Velocity</p>
<p>大数据时代的3高 ：<font color=red> 主要是对程序的要求</font></p>
</li>
<li><p>高并发</p>
</li>
<li><p>高可扩</p>
</li>
<li><p>高性能</p>
</li>
</ul>
<p><strong>真正在公司中的实践：<font color=red>NoSQL + RDBMS 一起使用才是最强的。</font></strong></p>
<h3 id="emsp-阿里巴巴演进分析"><a href="#emsp-阿里巴巴演进分析" class="headerlink" title="&emsp;阿里巴巴演进分析"></a>&emsp;阿里巴巴演进分析</h3><p><img src="https://img-blog.csdnimg.cn/2020082823531874.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><img src="https://img-blog.csdnimg.cn/20200828235343481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<pre class=" language-xml"><code class="language-xml"># 商品信息
- 一般存放在关系型数据库：Mysql,阿里巴巴使用的Mysql都是经过内部改动的。

# 商品描述、评论(文字居多)
- 文档型数据库：MongoDB

# 图片
- 分布式文件系统 FastDFS
- 淘宝：TFS
- Google: GFS
- Hadoop: HDFS
- 阿里云: oss

# 商品关键字 用于搜索
- 搜索引擎：solr,elasticsearch
- 阿里：Isearch 多隆

# 商品热门的波段信息
- 内存数据库：Redis，Memcache

# 商品交易，外部支付接口
- 第三方应用
</code></pre>
<h3 id="emsp-Nosql的四大分类"><a href="#emsp-Nosql的四大分类" class="headerlink" title="&emsp;Nosql的四大分类"></a>&emsp;Nosql的四大分类</h3><blockquote>
<p><strong>&emsp;&emsp;1.KV键值对</strong></p>
</blockquote>
<ul>
<li>新浪：<strong><font color=red>Redis</font></strong></li>
<li>美团：<strong><font color=red>Redis + Tair</font></strong></li>
<li>阿里、百度：<strong><font color=red>Redis + Memcache</font></strong></li>
</ul>
<blockquote>
<p><strong>2.文档型数据库（bson数据格式）：</strong></p>
</blockquote>
<ul>
<li><font color=red> <strong>MongoDB(掌握)</strong></font><ul>
<li>基于分布式文件存储的数据库。C++编写，用于处理大量文档。</li>
<li>MongoDB是RDBMS和NoSQL的中间产品。MongoDB是非关系型数据库中功能最丰富的，NoSQL中最像关系型数据库的数据库。</li>
</ul>
</li>
<li><font color=red><strong>ConthDB</strong></font></li>
</ul>
<blockquote>
<p><strong>3. 列存储数据库</strong></p>
</blockquote>
<ul>
<li>HBase(大数据必学)</li>
<li>分布式文件系统</li>
</ul>
<blockquote>
<p><strong>4.图关系数据库</strong></p>
</blockquote>
<ul>
<li><font color=red> 他不是存图形，放的是关系</font>，比如：朋友圈社交网络，广告推荐！</li>
<li>Neo4j，InfoGrid；</li>
</ul>
<p><strong><em>四者对比！</em></strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200829000634318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>Nosql</tag>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis入门——笔记二</title>
    <url>/2020/09/01/Redis%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<h2 id="二、Redis入门"><a href="#二、Redis入门" class="headerlink" title="二、Redis入门"></a>二、Redis入门</h2><h3 id="emsp-概述"><a href="#emsp-概述" class="headerlink" title="&emsp;概述"></a>&emsp;概述</h3><blockquote>
<p><font color=red> Redis是什么？</font></p>
</blockquote>
<p>&emsp;&emsp;Redis（Remote Dictionary Server )，即<font color=red>远程字典服务</font>。</p>
<p>&emsp;&emsp;是一个开源的使用<font color=red>ANSI,C语言</font>编写、<strong>支持网络</strong>、<strong>可基于内存亦可持久化</strong>的日志型、<strong>Key-Value数据库</strong>，并提供多种语言的API。</p>
<p>&emsp;&emsp;与memcached一样，为了保证效率，数据都是<font color=red><strong>缓存在内存中</strong></font>。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上<strong>实现了master-slave(主从)同步</strong>。</p>
<blockquote>
<p><font color=red>Redis能该干什么？</font></p>
</blockquote>
<ul>
<li>内存存储、持久化，内存是断电即失的，所以需要持久化（RDB、AOF）</li>
<li>高效率、用于高速缓冲</li>
<li>发布订阅系统</li>
<li>地图信息分析</li>
<li>计时器、计数器(eg：浏览量)</li>
</ul>
<blockquote>
<p><font color=red>特性</font></p>
</blockquote>
<ul>
<li>多样的数据类型</li>
<li>持久化</li>
<li>集群</li>
<li>事务</li>
</ul>
<h3 id="emsp-Linux安装"><a href="#emsp-Linux安装" class="headerlink" title="&emsp;Linux安装"></a>&emsp;Linux安装</h3><p>1.下载安装包！redis-5.0.8.tar.gz</p>
<p>2.解压Redis的安装包！程序一般放在 /opt 目录下</p>
<p><img src="https://img-blog.csdnimg.cn/20200830213910843.png#pic_center" alt=""><br>3.基本环境安装</p>
<pre class=" language-xml"><code class="language-xml">yum install gcc-c++
# 然后进入redis目录下执行
make
# 然后执行
make install</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200830214011366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>redis默认安装路径 /usr/local/bin</p>
<p><img src="https://img-blog.csdnimg.cn/20200830214045525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>将redis的配置文件复制到 程序安装目录 /usr/local/bin/kconfig下</p>
<p><img src="https://img-blog.csdnimg.cn/20200830214104359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>redis默认不是后台启动的，需要修改配置文件！</p>
<p><img src="https://img-blog.csdnimg.cn/20200830214125276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>通过制定的配置文件启动redis服务<br><img src="https://img-blog.csdnimg.cn/20200830214142684.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>使用redis-cli连接指定的端口号测试，Redis的默认端口6379<br><img src="https://img-blog.csdnimg.cn/20200830214209578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>查看redis进程是否开启<br><img src="https://img-blog.csdnimg.cn/20200830214225921.png#pic_center" alt=""><br>关闭Redis服务 shutdown<br><img src="https://img-blog.csdnimg.cn/20200830214244178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>再次查看进程是否存在</p>
<p>后面我们会使用单机多Redis启动集群测试</p>
<h3 id="emsp-测试性能"><a href="#emsp-测试性能" class="headerlink" title="&emsp;测试性能"></a>&emsp;测试性能</h3><p>redis-benchmark：Redis官方提供的性能测试工具，参数选项如下：<br><img src="https://img-blog.csdnimg.cn/20200830214451655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>简单测试：</strong></p>
<pre class=" language-xml"><code class="language-xml"># 测试：100个并发连接 100000请求
redis-benchmark -h localhost -p 6379 -c 100 -n 100000
12</code></pre>
<p><img src="https://img-blog.csdnimg.cn/2020083021454238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h3 id="emsp-基础知识"><a href="#emsp-基础知识" class="headerlink" title="&emsp;基础知识"></a>&emsp;基础知识</h3><blockquote>
<p><font color=red>redis默认有16个数据库</font></p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200830214916115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>默认使用的第0个;</p>
<p>16个数据库为：DB 0~DB 15</p>
<p>默认使用DB 0 ，可以使用<font color=red>select n</font>切换到DB n，<font color=red>dbsize</font>可以查看当前数据库的大小，与key数量相关</p>
<pre class=" language-xml"><code class="language-xml">127.0.0.1:6379> config get databases # 命令行查看数据库数量databases
1) "databases"
2) "16"

127.0.0.1:6379> select 8 # 切换数据库 DB 8
OK
127.0.0.1:6379[8]> dbsize # 查看数据库大小
(integer) 0

# 不同数据库之间 数据是不能互通的，并且dbsize 是根据库中key的个数。
127.0.0.1:6379> set name sakura 
OK
127.0.0.1:6379> SELECT 8
OK
127.0.0.1:6379[8]> get name # db8中并不能获取db0中的键值对。
(nil)
127.0.0.1:6379[8]> DBSIZE
(integer) 0
127.0.0.1:6379[8]> SELECT 0
OK
127.0.0.1:6379> keys *
1) "counter:__rand_int__"
2) "mylist"
3) "name"
4) "key:__rand_int__"
5) "myset:__rand_int__"
127.0.0.1:6379> DBSIZE # size和key个数相关
(integer) 5
</code></pre>
<p><font color=red>keys *</font> ：<strong>查看当前数据库中所有的key。</strong></p>
<p><font color=red>flushdb</font>：<strong>清空当前数据库中的键值对。</strong></p>
<p><font color=red>flushall</font>：<strong>清空所有数据库的键值对。</strong></p>
<blockquote>
<p><font color=red>Redis是单线程的，Redis是基于内存操作的。</font></p>
</blockquote>
<p>&emsp;&emsp;所以Redis的性能瓶颈不是CPU,而是<font color=red>机器内存</font>和<font color=red>网络带宽</font>。</p>
<p>&emsp;&emsp;那么为什么Redis的速度如此快呢，性能这么高呢？QPS达到10W+</p>
<blockquote>
<p><font color=red>Redis为什么单线程还这么快？</font></p>
</blockquote>
<ul>
<li>误区1：高性能的服务器一定是多线程的？</li>
<li>误区2：多线程（CPU上下文会切换！）一定比单线程效率高！</li>
</ul>
<p><strong>&emsp;&emsp;<font color=red>核心</font>：Redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。</strong></p>
<h2 id="三、五大数据类型"><a href="#三、五大数据类型" class="headerlink" title="三、五大数据类型"></a>三、五大数据类型</h2><p> &emsp;&emsp;Redis是一个开源（BSD许可），内存存储的数据结构服务器，可用作<strong>数据库，高速缓存和消息队列代理</strong>。它支持<font color=blue>字符串、哈希表、列表、集合、有序集合，位图，hyperloglogs</font>等数据类型。内置复制、Lua脚本、LRU收回、事务以及不同级别磁盘持久化功能，同时通过Redis Sentinel提供高可用，通过Redis Cluster提供自动分区。</p>
<h3 id="emsp-Redis-key"><a href="#emsp-Redis-key" class="headerlink" title="&emsp;Redis-key"></a>&emsp;Redis-key</h3><blockquote>
<p>&emsp;&emsp;在redis中无论什么数据类型，在数据库中都是以<font color=red>key-value形式保存</font>，通过进行对<font color=red>Redis-key</font>的操作，来完成对数据库中数据的操作。</p>
</blockquote>
<p>下面学习的命令：</p>
<ul>
<li><font color=red>exists key</font>：判断键是否存在</li>
<li><font color=red>del key</font>：删除键值对</li>
<li><font color=red>move key db</font>：将键值对移动到指定数据库</li>
<li><font color=red>expire key second</font>：设置键值对的过期时间</li>
<li><font color=red>type key</font>：查看value的数据类型</li>
</ul>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> keys * <span class="token comment" spellcheck="true"># 查看当前数据库所有key</span>
<span class="token punctuation">(</span>empty list or set<span class="token punctuation">)</span>
127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> name qinjiang <span class="token comment" spellcheck="true"># set key</span>
OK
127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> age 20
OK
127.0.0.1:6379<span class="token operator">></span> keys *
1<span class="token punctuation">)</span> <span class="token string">"age"</span>
2<span class="token punctuation">)</span> <span class="token string">"name"</span>
127.0.0.1:6379<span class="token operator">></span> move age 1 <span class="token comment" spellcheck="true"># 将键值对移动到指定数据库</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> EXISTS age <span class="token comment" spellcheck="true"># 判断键是否存在</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0 <span class="token comment" spellcheck="true"># 不存在</span>
127.0.0.1:6379<span class="token operator">></span> EXISTS name
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1 <span class="token comment" spellcheck="true"># 存在</span>
127.0.0.1:6379<span class="token operator">></span> SELECT 1
OK
127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> keys *
1<span class="token punctuation">)</span> <span class="token string">"age"</span>
127.0.0.1:6379<span class="token punctuation">[</span>1<span class="token punctuation">]</span><span class="token operator">></span> del age <span class="token comment" spellcheck="true"># 删除键值对</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1 <span class="token comment" spellcheck="true"># 删除个数</span>


127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> age 20
OK
127.0.0.1:6379<span class="token operator">></span> EXPIRE age 15 <span class="token comment" spellcheck="true"># 设置键值对的过期时间</span>

<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1 <span class="token comment" spellcheck="true"># 设置成功 开始计数</span>
127.0.0.1:6379<span class="token operator">></span> ttl age <span class="token comment" spellcheck="true"># 查看key的过期剩余时间</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 13
127.0.0.1:6379<span class="token operator">></span> ttl age
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 11
127.0.0.1:6379<span class="token operator">></span> ttl age
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 9
127.0.0.1:6379<span class="token operator">></span> ttl age
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -2 <span class="token comment" spellcheck="true"># -2 表示key过期，-1表示key未设置过期时间</span>

127.0.0.1:6379<span class="token operator">></span> get age <span class="token comment" spellcheck="true"># 过期的key 会被自动delete</span>
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
127.0.0.1:6379<span class="token operator">></span> keys *
1<span class="token punctuation">)</span> <span class="token string">"name"</span>

127.0.0.1:6379<span class="token operator">></span> <span class="token function">type</span> name <span class="token comment" spellcheck="true"># 查看value的数据类型</span>
string</code></pre>
<p>关于TTL命令</p>
<p>Redis的key，通过TTL命令返回key的过期时间，一般来说有3种：</p>
<ul>
<li>当前key没有设置过期时间，所以会返回-1.</li>
<li>当前key有设置过期时间，而且key已经过期，所以会返回-2.</li>
<li>当前key有设置过期时间，且key还没有过期，故会返回key的正常剩余时间.</li>
</ul>
<p>关于重命名<font color=red>RENAME</font>和<font color=red>RENAMENX</font></p>
<ul>
<li><font color=red>RENAME key newkey</font>修改 key 的名称</li>
<li><font color=red>RENAMENX key newkey</font>仅当 newkey 不存在时，将 key 改名为 newkey 。</li>
</ul>
<h3 id="emsp-String-字符串"><a href="#emsp-String-字符串" class="headerlink" title="&emsp;String(字符串)"></a>&emsp;String(字符串)</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>APPEND key value</td>
<td>向指定的key的value后追加字符串</td>
<td>127.0.0.1:6379&gt; set msg hello OK 127.0.0.1:6379&gt; append msg “ world” (integer) 11 127.0.0.1:6379&gt; get msg “hello world”</td>
</tr>
<tr>
<td>DECR/INCR key</td>
<td>将指定key的value数值进行+1/-1(仅对于数字)</td>
<td>127.0.0.1:6379&gt; set age 20 OK 127.0.0.1:6379&gt; incr age (integer) 21 127.0.0.1:6379&gt; decr age (integer) 20</td>
</tr>
<tr>
<td>INCRBY/DECRBY key n</td>
<td>按指定的步长对数值进行加减</td>
<td>127.0.0.1:6379&gt; INCRBY age 5 (integer) 25 127.0.0.1:6379&gt; DECRBY age 10 (integer) 15</td>
</tr>
<tr>
<td>INCRBYFLOAT key n</td>
<td>为数值加上浮点型数值</td>
<td>127.0.0.1:6379&gt; INCRBYFLOAT age 5.2 “20.2”</td>
</tr>
<tr>
<td><font color=red> STRLEN key</font></td>
<td>获取key保存值的字符串长度</td>
<td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; STRLEN msg (integer) 11</td>
</tr>
<tr>
<td><font color=red>GETRANGE key start end </font></td>
<td>按起止位置获取字符串（闭区间，起止位置都取）</td>
<td>127.0.0.1:6379&gt; get msg “hello world” 127.0.0.1:6379&gt; GETRANGE msg 3 9 “lo worl”</td>
</tr>
<tr>
<td><font color=red>SETRANGE key offset value </font></td>
<td>用指定的value 替换key中 offset开始的值</td>
<td>127.0.0.1:6379&gt; SETRANGE msg 2 hello (integer) 7 127.0.0.1:6379&gt; get msg “tehello”</td>
</tr>
<tr>
<td><font color=red>GETSET key value </font></td>
<td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)。</td>
<td>127.0.0.1:6379&gt; GETSET msg test “hello world”</td>
</tr>
<tr>
<td><font color=red>SETNX key value     </font></td>
<td>仅当key不存在时进行set</td>
<td>127.0.0.1:6379&gt; SETNX msg test (integer) 0 127.0.0.1:6379&gt; SETNX name sakura (integer) 1</td>
</tr>
<tr>
<td><font color=red>SETEX key seconds value </font></td>
<td>set 键值对并设置过期时间</td>
<td>127.0.0.1:6379&gt; setex name 10 root OK 127.0.0.1:6379&gt; get name (nil)</td>
</tr>
<tr>
<td><font color=red>MSET key1 value1 [key2 value2..]     </font></td>
<td>批量set键值对</td>
<td>127.0.0.1:6379&gt; MSET k1 v1 k2 v2 k3 v3 OK</td>
</tr>
<tr>
<td><font color=red>MSETNX key1 value1 [key2 value2..] </font></td>
<td>批量设置键值对，仅当参数中所有的key都不存在时执行</td>
<td>127.0.0.1:6379&gt; MSETNX k1 v1 k4 v4 (integer) 0</td>
</tr>
<tr>
<td><font color=red>MGET key1 [key2..] </font></td>
<td>批量获取多个key保存的值</td>
<td>127.0.0.1:6379&gt; MGET k1 k2 k3 1) “v1” 2) “v2” 3) “v3”</td>
</tr>
<tr>
<td><font color=red> PSETEX key milliseconds value</font></td>
<td>和 SETEX 命令相似，但它以毫秒为单位设置 key 的生存时间，</td>
<td></td>
</tr>
<tr>
<td><font color=red> getset key value</font></td>
<td>如果不存在值，则返回nil，如果存在值，获取原来的值，并设置新的值</td>
<td></td>
</tr>
</tbody></table>
<p>String类似的使用场景：value除了是字符串还可以是数字，用途举例：</p>
<ul>
<li>计数器</li>
<li>统计多单位的数量：uid:123666：follow 0<ul>
<li>粉丝数</li>
<li>对象存储缓存</li>
</ul>
</li>
</ul>
<h3 id="emsp-List-列表"><a href="#emsp-List-列表" class="headerlink" title="&emsp;List(列表)"></a>&emsp;List(列表)</h3><blockquote>
<p>Redis列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）<br>一个列表最多可以包含 232 - 1 个元素 (4294967295, 每个列表超过40亿个元素)。</p>
</blockquote>
<p>首先我们列表，可以经过规则定义将其变为队列、栈、双端队列等</p>
<p><img src="https://img-blog.csdnimg.cn/2020083100424595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>正如图Redis中List是可以进行双端操作的，所以命令也就分为了LXXX和RLLL两类，有时候L也表示List例如LLEN</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><font color=red>LPUSH/RPUSH key value1[value2..]    </font></td>
<td>从左边/右边向列表中PUSH值(一个或者多个)。</td>
</tr>
<tr>
<td><font color=red>LRANGE key start end</font></td>
<td>获取list 起止元素<strong>（索引从左往右 递增）</strong></td>
</tr>
<tr>
<td><font color=red>LPUSHX/RPUSHX key value</font></td>
<td>向已存在的列名中push值（一个或者多个）</td>
</tr>
<tr>
<td><font color=red>LINSERT key BEFORE/AFTER pivot value</font></td>
<td>在指定列表元素的前/后 插入value</td>
</tr>
<tr>
<td><font color=red>LLEN key</font></td>
<td>查看列表长度</td>
</tr>
<tr>
<td><font color=red>LINDEX key index    </font></td>
<td>通过索引获取列表元素</td>
</tr>
<tr>
<td><font color=red>LSET key index value    </font></td>
<td>通过索引为元素设值</td>
</tr>
<tr>
<td><font color=red>LPOP/RPOP key</font></td>
<td>从最左边/最右边移除值 并返回</td>
</tr>
<tr>
<td><font color=red>RPOPLPUSH source destination</font></td>
<td>将列表的尾部(右)最后一个值弹出，并返回，然后加到另一个列表的头部</td>
</tr>
<tr>
<td><font color=red>LTRIM key start end    </font></td>
<td>通过下标截取指定范围内的列表</td>
</tr>
<tr>
<td><font color=red>LREM key count value</font></td>
<td>List中是允许value重复的 count &gt; 0：从头部开始搜索 然后删除指定的value 至多删除count个 count &lt; 0：从尾部开始搜索… count = 0：删除列表中所有的指定value。</td>
</tr>
<tr>
<td><font color=red>BLPOP/BRPOP key1[key2] timout</font></td>
<td>移出并获取列表的第一个/最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td><font color=red>BRPOPLPUSH source destination timeout</font></td>
<td>和RPOPLPUSH功能相同，如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
</tbody></table>
<pre class=" language-bash"><code class="language-bash">---------------------------LPUSH---RPUSH---LRANGE--------------------------------

127.0.0.1:6379<span class="token operator">></span> LPUSH mylist k1 <span class="token comment" spellcheck="true"># LPUSH mylist=>{1}</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> LPUSH mylist k2 <span class="token comment" spellcheck="true"># LPUSH mylist=>{2,1}</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
127.0.0.1:6379<span class="token operator">></span> RPUSH mylist k3 <span class="token comment" spellcheck="true"># RPUSH mylist=>{2,1,3}</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
127.0.0.1:6379<span class="token operator">></span> get mylist <span class="token comment" spellcheck="true"># 普通的get是无法获取list值的</span>
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> WRONGTYPE Operation against a key holding the wrong kind of value
127.0.0.1:6379<span class="token operator">></span> LRANGE mylist 0 4 <span class="token comment" spellcheck="true"># LRANGE 获取起止位置范围内的元素</span>
1<span class="token punctuation">)</span> <span class="token string">"k2"</span>
2<span class="token punctuation">)</span> <span class="token string">"k1"</span>
3<span class="token punctuation">)</span> <span class="token string">"k3"</span>
127.0.0.1:6379<span class="token operator">></span> LRANGE mylist 0 2
1<span class="token punctuation">)</span> <span class="token string">"k2"</span>
2<span class="token punctuation">)</span> <span class="token string">"k1"</span>
3<span class="token punctuation">)</span> <span class="token string">"k3"</span>
127.0.0.1:6379<span class="token operator">></span> LRANGE mylist 0 1
1<span class="token punctuation">)</span> <span class="token string">"k2"</span>
2<span class="token punctuation">)</span> <span class="token string">"k1"</span>
127.0.0.1:6379<span class="token operator">></span> LRANGE mylist 0 -1 <span class="token comment" spellcheck="true"># 获取全部元素</span>
1<span class="token punctuation">)</span> <span class="token string">"k2"</span>
2<span class="token punctuation">)</span> <span class="token string">"k1"</span>
3<span class="token punctuation">)</span> <span class="token string">"k3"</span>

---------------------------LPUSHX---RPUSHX-----------------------------------

127.0.0.1:6379<span class="token operator">></span> LPUSHX list v1 <span class="token comment" spellcheck="true"># list不存在 LPUSHX失败</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1:6379<span class="token operator">></span> LPUSHX list v1 v2  
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1:6379<span class="token operator">></span> LPUSHX mylist k4 k5 <span class="token comment" spellcheck="true"># 向mylist中 左边 PUSH k4 k5</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5
127.0.0.1:6379<span class="token operator">></span> LRANGE mylist 0 -1
1<span class="token punctuation">)</span> <span class="token string">"k5"</span>
2<span class="token punctuation">)</span> <span class="token string">"k4"</span>
3<span class="token punctuation">)</span> <span class="token string">"k2"</span>
4<span class="token punctuation">)</span> <span class="token string">"k1"</span>
5<span class="token punctuation">)</span> <span class="token string">"k3"</span>

---------------------------LINSERT--LLEN--LINDEX--LSET----------------------------

127.0.0.1:6379<span class="token operator">></span> LINSERT mylist after k2 ins_key1 <span class="token comment" spellcheck="true"># 在k2元素后 插入ins_key1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6
127.0.0.1:6379<span class="token operator">></span> LRANGE mylist 0 -1
1<span class="token punctuation">)</span> <span class="token string">"k5"</span>
2<span class="token punctuation">)</span> <span class="token string">"k4"</span>
3<span class="token punctuation">)</span> <span class="token string">"k2"</span>
4<span class="token punctuation">)</span> <span class="token string">"ins_key1"</span>
5<span class="token punctuation">)</span> <span class="token string">"k1"</span>
6<span class="token punctuation">)</span> <span class="token string">"k3"</span>
127.0.0.1:6379<span class="token operator">></span> LLEN mylist <span class="token comment" spellcheck="true"># 查看mylist的长度</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 6
127.0.0.1:6379<span class="token operator">></span> LINDEX mylist 3 <span class="token comment" spellcheck="true"># 获取下标为3的元素</span>
<span class="token string">"ins_key1"</span>
127.0.0.1:6379<span class="token operator">></span> LINDEX mylist 0
<span class="token string">"k5"</span>
127.0.0.1:6379<span class="token operator">></span> LSET mylist 3 k6 <span class="token comment" spellcheck="true"># 将下标3的元素 set值为k6</span>
OK
127.0.0.1:6379<span class="token operator">></span> LRANGE mylist 0 -1
1<span class="token punctuation">)</span> <span class="token string">"k5"</span>
2<span class="token punctuation">)</span> <span class="token string">"k4"</span>
3<span class="token punctuation">)</span> <span class="token string">"k2"</span>
4<span class="token punctuation">)</span> <span class="token string">"k6"</span>
5<span class="token punctuation">)</span> <span class="token string">"k1"</span>
6<span class="token punctuation">)</span> <span class="token string">"k3"</span>

---------------------------LPOP--RPOP--------------------------

127.0.0.1:6379<span class="token operator">></span> LPOP mylist <span class="token comment" spellcheck="true"># 左侧(头部)弹出</span>
<span class="token string">"k5"</span>
127.0.0.1:6379<span class="token operator">></span> RPOP mylist <span class="token comment" spellcheck="true"># 右侧(尾部)弹出</span>
<span class="token string">"k3"</span>

---------------------------RPOPLPUSH--------------------------

127.0.0.1:6379<span class="token operator">></span> LRANGE mylist 0 -1
1<span class="token punctuation">)</span> <span class="token string">"k4"</span>
2<span class="token punctuation">)</span> <span class="token string">"k2"</span>
3<span class="token punctuation">)</span> <span class="token string">"k6"</span>
4<span class="token punctuation">)</span> <span class="token string">"k1"</span>
127.0.0.1:6379<span class="token operator">></span> RPOPLPUSH mylist newlist <span class="token comment" spellcheck="true"># 将mylist的最后一个值(k1)弹出，加入到newlist的头部</span>
<span class="token string">"k1"</span>
127.0.0.1:6379<span class="token operator">></span> LRANGE newlist 0 -1
1<span class="token punctuation">)</span> <span class="token string">"k1"</span>
127.0.0.1:6379<span class="token operator">></span> LRANGE mylist 0 -1
1<span class="token punctuation">)</span> <span class="token string">"k4"</span>
2<span class="token punctuation">)</span> <span class="token string">"k2"</span>
3<span class="token punctuation">)</span> <span class="token string">"k6"</span>

---------------------------LTRIM--------------------------

127.0.0.1:6379<span class="token operator">></span> LTRIM mylist 0 1 <span class="token comment" spellcheck="true"># 截取mylist中的 0~1部分</span>
OK
127.0.0.1:6379<span class="token operator">></span> LRANGE mylist 0 -1
1<span class="token punctuation">)</span> <span class="token string">"k4"</span>
2<span class="token punctuation">)</span> <span class="token string">"k2"</span>

<span class="token comment" spellcheck="true"># 初始 mylist: k2,k2,k2,k2,k2,k2,k4,k2,k2,k2,k2</span>
---------------------------LREM--------------------------

127.0.0.1:6379<span class="token operator">></span> LREM mylist 3 k2 <span class="token comment" spellcheck="true"># 从头部开始搜索 至多删除3个 k2</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
<span class="token comment" spellcheck="true"># 删除后：mylist: k2,k2,k2,k4,k2,k2,k2,k2</span>

127.0.0.1:6379<span class="token operator">></span> LREM mylist -2 k2 <span class="token comment" spellcheck="true">#从尾部开始搜索 至多删除2个 k2</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
<span class="token comment" spellcheck="true"># 删除后：mylist: k2,k2,k2,k4,k2,k2</span>


---------------------------BLPOP--BRPOP--------------------------

mylist: k2,k2,k2,k4,k2,k2
newlist: k1

127.0.0.1:6379<span class="token operator">></span> BLPOP newlist mylist 30 <span class="token comment" spellcheck="true"># 从newlist中弹出第一个值，mylist作为候选</span>
1<span class="token punctuation">)</span> <span class="token string">"newlist"</span> <span class="token comment" spellcheck="true"># 弹出</span>
2<span class="token punctuation">)</span> <span class="token string">"k1"</span>
127.0.0.1:6379<span class="token operator">></span> BLPOP newlist mylist 30
1<span class="token punctuation">)</span> <span class="token string">"mylist"</span> <span class="token comment" spellcheck="true"># 由于newlist空了 从mylist中弹出</span>
2<span class="token punctuation">)</span> <span class="token string">"k2"</span>
127.0.0.1:6379<span class="token operator">></span> BLPOP newlist 30
<span class="token punctuation">(</span>30.10s<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 超时了</span>

127.0.0.1:6379<span class="token operator">></span> BLPOP newlist 30 <span class="token comment" spellcheck="true"># 我们连接另一个客户端向newlist中push了test, 阻塞被解决。</span>
1<span class="token punctuation">)</span> <span class="token string">"newlist"</span>
2<span class="token punctuation">)</span> <span class="token string">"test"</span>
<span class="token punctuation">(</span>12.54s<span class="token punctuation">)</span>
</code></pre>
<blockquote>
<p>小结</p>
</blockquote>
<ul>
<li>list实际上是一个链表，before Node after , left, right 都可以插入值</li>
<li>如果key不存在，则创建新的链表</li>
<li>如果key存在，新增内容</li>
<li>如果移除了所有值，空链表，也代表不存在</li>
<li>在两边插入或者改动值，效率最高！修改中间元素，效率相对较低</li>
</ul>
<p><strong>应用：<br>消息排队！消息队列（Lpush Rpop）,栈（Lpush Lpop）</strong></p>
<h3 id="emsp-Set-集合"><a href="#emsp-Set-集合" class="headerlink" title="&emsp;Set(集合)"></a>&emsp;Set(集合)</h3><blockquote>
<p>Redis的Set是string类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。<br>Redis 中 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。<br>集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><font color=red>SADD key member1[member2..]</font></td>
<td>向集合中无序增加一个/多个成员</td>
</tr>
<tr>
<td><font color=red>SCARD key</font></td>
<td>获取集合的成员数</td>
</tr>
<tr>
<td><font color=red>SMEMBERS key</font></td>
<td>返回集合中所有的成员</td>
</tr>
<tr>
<td><font color=red>SISMEMBER key member</font></td>
<td>查询member元素是否是集合的成员,结果是无序的</td>
</tr>
<tr>
<td><font color=red>SRANDMEMBER key [count]</font></td>
<td>随机返回集合中count个成员，count缺省值为1</td>
</tr>
<tr>
<td><font color=red>SPOP key [count]</font></td>
<td>随机移除并返回集合中count个成员，count缺省值为1</td>
</tr>
<tr>
<td><font color=red>SMOVE source destination member</font></td>
<td>将source集合的成员member移动到destination集合</td>
</tr>
<tr>
<td><font color=red>SREM key member1[member2..]</font></td>
<td>移除集合中一个/多个成员</td>
</tr>
<tr>
<td><font color=red>SDIFF key1[key2..]</font></td>
<td>返回所有集合的差集 key1- key2 - …</td>
</tr>
<tr>
<td><font color=red>SDIFFSTORE destination key1[key2..]</font></td>
<td>在SDIFF的基础上，将结果保存到集合中<strong>(覆盖)</strong>。不能保存到其他类型key噢！</td>
</tr>
<tr>
<td><font color=red>SINTER key1 [key2..]</font></td>
<td>返回所有集合的交集</td>
</tr>
<tr>
<td><font color=red>SINTERSTORE destination key1[key2..]    </font></td>
<td>在SINTER的基础上，存储结果到集合中。覆盖</td>
</tr>
<tr>
<td><font color=red>SUNION key1 [key2..]</font></td>
<td>返回所有集合的并集</td>
</tr>
<tr>
<td><font color=red>SUNIONSTORE destination key1 [key2..]    </font></td>
<td>在SUNION的基础上，存储结果到及和张。覆盖</td>
</tr>
<tr>
<td><font color=red>SSCAN KEY [MATCH pattern] [COUNT count]</font></td>
<td>在大量数据环境下，使用此命令遍历集合中元素，每次遍历部分</td>
</tr>
</tbody></table>
<pre class=" language-bash"><code class="language-bash">---------------SADD--SCARD--SMEMBERS--SISMEMBER--------------------

127.0.0.1:6379<span class="token operator">></span> SADD myset m1 m2 m3 m4 <span class="token comment" spellcheck="true"># 向myset中增加成员 m1~m4</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4
127.0.0.1:6379<span class="token operator">></span> SCARD myset <span class="token comment" spellcheck="true"># 获取集合的成员数目</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4
127.0.0.1:6379<span class="token operator">></span> smembers myset <span class="token comment" spellcheck="true"># 获取集合中所有成员</span>
1<span class="token punctuation">)</span> <span class="token string">"m4"</span>
2<span class="token punctuation">)</span> <span class="token string">"m3"</span>
3<span class="token punctuation">)</span> <span class="token string">"m2"</span>
4<span class="token punctuation">)</span> <span class="token string">"m1"</span>
127.0.0.1:6379<span class="token operator">></span> SISMEMBER myset m5 <span class="token comment" spellcheck="true"># 查询m5是否是myset的成员</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0 <span class="token comment" spellcheck="true"># 不是，返回0</span>
127.0.0.1:6379<span class="token operator">></span> SISMEMBER myset m2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1 <span class="token comment" spellcheck="true"># 是，返回1</span>
127.0.0.1:6379<span class="token operator">></span> SISMEMBER myset m3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

---------------------SRANDMEMBER--SPOP----------------------------------

127.0.0.1:6379<span class="token operator">></span> SRANDMEMBER myset 3 <span class="token comment" spellcheck="true"># 随机返回3个成员</span>
1<span class="token punctuation">)</span> <span class="token string">"m2"</span>
2<span class="token punctuation">)</span> <span class="token string">"m3"</span>
3<span class="token punctuation">)</span> <span class="token string">"m4"</span>
127.0.0.1:6379<span class="token operator">></span> SRANDMEMBER myset <span class="token comment" spellcheck="true"># 随机返回1个成员</span>
<span class="token string">"m3"</span>
127.0.0.1:6379<span class="token operator">></span> SPOP myset 2 <span class="token comment" spellcheck="true"># 随机移除并返回2个成员</span>
1<span class="token punctuation">)</span> <span class="token string">"m1"</span>
2<span class="token punctuation">)</span> <span class="token string">"m4"</span>
<span class="token comment" spellcheck="true"># 将set还原到{m1,m2,m3,m4}</span>

---------------------SMOVE--SREM----------------------------------------

127.0.0.1:6379<span class="token operator">></span> SMOVE myset newset m3 <span class="token comment" spellcheck="true"># 将myset中m3成员移动到newset集合</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> SMEMBERS myset
1<span class="token punctuation">)</span> <span class="token string">"m4"</span>
2<span class="token punctuation">)</span> <span class="token string">"m2"</span>
3<span class="token punctuation">)</span> <span class="token string">"m1"</span>
127.0.0.1:6379<span class="token operator">></span> SMEMBERS newset
1<span class="token punctuation">)</span> <span class="token string">"m3"</span>
127.0.0.1:6379<span class="token operator">></span> SREM newset m3 <span class="token comment" spellcheck="true"># 从newset中移除m3元素</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> SMEMBERS newset
<span class="token punctuation">(</span>empty list or set<span class="token punctuation">)</span>

<span class="token comment" spellcheck="true"># 下面开始是多集合操作,多集合操作中若只有一个参数默认和自身进行运算</span>
<span class="token comment" spellcheck="true"># setx=>{m1,m2,m4,m6}, sety=>{m2,m5,m6}, setz=>{m1,m3,m6}</span>

-----------------------------SDIFF------------------------------------

127.0.0.1:6379<span class="token operator">></span> SDIFF setx sety setz <span class="token comment" spellcheck="true"># 等价于setx-sety-setz</span>
1<span class="token punctuation">)</span> <span class="token string">"m4"</span>
127.0.0.1:6379<span class="token operator">></span> SDIFF setx sety <span class="token comment" spellcheck="true"># setx - sety</span>
1<span class="token punctuation">)</span> <span class="token string">"m4"</span>
2<span class="token punctuation">)</span> <span class="token string">"m1"</span>
127.0.0.1:6379<span class="token operator">></span> SDIFF sety setx <span class="token comment" spellcheck="true"># sety - setx</span>
1<span class="token punctuation">)</span> <span class="token string">"m5"</span>


-------------------------SINTER---------------------------------------
<span class="token comment" spellcheck="true"># 共同关注（交集）</span>

127.0.0.1:6379<span class="token operator">></span> SINTER setx sety setz <span class="token comment" spellcheck="true"># 求 setx、sety、setx的交集</span>
1<span class="token punctuation">)</span> <span class="token string">"m6"</span>
127.0.0.1:6379<span class="token operator">></span> SINTER setx sety <span class="token comment" spellcheck="true"># 求setx sety的交集</span>
1<span class="token punctuation">)</span> <span class="token string">"m2"</span>
2<span class="token punctuation">)</span> <span class="token string">"m6"</span>

-------------------------SUNION---------------------------------------

127.0.0.1:6379<span class="token operator">></span> SUNION setx sety setz <span class="token comment" spellcheck="true"># setx sety setz的并集</span>
1<span class="token punctuation">)</span> <span class="token string">"m4"</span>
2<span class="token punctuation">)</span> <span class="token string">"m6"</span>
3<span class="token punctuation">)</span> <span class="token string">"m3"</span>
4<span class="token punctuation">)</span> <span class="token string">"m2"</span>
5<span class="token punctuation">)</span> <span class="token string">"m1"</span>
6<span class="token punctuation">)</span> <span class="token string">"m5"</span>
127.0.0.1:6379<span class="token operator">></span> SUNION setx sety <span class="token comment" spellcheck="true"># setx sety 并集</span>
1<span class="token punctuation">)</span> <span class="token string">"m4"</span>
2<span class="token punctuation">)</span> <span class="token string">"m6"</span>
3<span class="token punctuation">)</span> <span class="token string">"m2"</span>
4<span class="token punctuation">)</span> <span class="token string">"m1"</span>
5<span class="token punctuation">)</span> <span class="token string">"m5"</span>
</code></pre>
<h2 id="四、三种特殊数据类型"><a href="#四、三种特殊数据类型" class="headerlink" title="四、三种特殊数据类型"></a>四、三种特殊数据类型</h2><h3 id="emsp-Geospatial-地理位置"><a href="#emsp-Geospatial-地理位置" class="headerlink" title="&emsp;Geospatial(地理位置)"></a>&emsp;Geospatial(地理位置)</h3><blockquote>
<p>使用经纬度定位地理坐标并用一个<strong>有序集合zset保存</strong>，所以<strong>zset命令也可以使用</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><font color=red>geoadd key longitud(经度) latitude(纬度) member [..]    </font></td>
<td>将具体经纬度的坐标存入一个有序集合</td>
</tr>
<tr>
<td><font color=red>geopos key member [member..]</font></td>
<td>获取集合中的一个/多个成员坐标</td>
</tr>
<tr>
<td><font color=red>geodist key member1 member2 [unit]</font></td>
<td>返回两个给定位置之间的距离。默认以米作为单位。</td>
</tr>
<tr>
<td><font color=red>georadius key longitude latitude radius m/km/mi/ft [WITHCOORD][WITHDIST] [WITHHASH] [COUNT count]</font></td>
<td>以给定的经纬度为中心， 返回集合包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</td>
</tr>
<tr>
<td><font color=red>GEORADIUSBYMEMBER key member radius…</font></td>
<td>功能与GEORADIUS相同，只是中心位置不是具体的经纬度，而是使用结合中已有的成员作为中心点。</td>
</tr>
<tr>
<td><font color=red>geohash key member1 [member2..]</font></td>
<td>返回一个或多个位置元素的Geohash表示。使用Geohash位置52点整数编码。</td>
</tr>
</tbody></table>
<p><strong>有效经纬度</strong></p>
<blockquote>
<ul>
<li>有效的经度从-180度到180度。<ul>
<li>有效的纬度从-85.05112878度到85.05112878度。</li>
</ul>
</li>
</ul>
</blockquote>
<p>指定单位的参数 <strong>unit</strong> 必须是以下单位的其中一个：</p>
<ul>
<li><strong>m</strong> 表示单位为米。</li>
<li><strong>km</strong> 表示单位为千米。</li>
<li><strong>mi</strong> 表示单位为英里。</li>
<li><strong>ft</strong> 表示单位为英尺。</li>
</ul>
<pre class=" language-bash"><code class="language-bash">-----------------geoadd--------------------
127.0.0.1:6379<span class="token operator">></span> geoadd china:city 111.4 30.5 yichang <span class="token comment" spellcheck="true"># 将经纬度(111.4,30.5)的地理坐标加入china:city 并命名yichang</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> geoadd china:city 121.4 31.4 shanghai <span class="token comment" spellcheck="true"># ...</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> geoadd china:city 120.2 30.2 hangzhou
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> geoadd china:city 104.1 30.6 chengdu
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1

-----------------geopos--------------------
127.0.0.1:6379<span class="token operator">></span> geopos china:city shanghai
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"121.40000134706497"</span> <span class="token comment" spellcheck="true"># 经度</span>
   2<span class="token punctuation">)</span> <span class="token string">"31.400000253193539"</span> <span class="token comment" spellcheck="true"># 纬度</span>

-----------------geodist--------------------
127.0.0.1:6379<span class="token operator">></span> GEODIST china:city yichang shanghai <span class="token comment" spellcheck="true"># 获取yichang和shanghai两个地理坐标的距离(单位:m)</span>
<span class="token string">"958793.6834"</span>
127.0.0.1:6379<span class="token operator">></span> GEODIST china:city shanghai yichang km <span class="token comment" spellcheck="true"># 单位：km</span>
<span class="token string">"958.7937"</span>
</code></pre>
<p><strong>关于GEORADIUS的参数</strong></p>
<blockquote>
<p>通过<font color=red>georadius</font>就可以完成 附近的人功能<br>withcoord:带上坐标<br>withdist:带上距离，单位与半径单位相同<br>COUNT n : 只显示前n个(按距离递增排序)</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash">----------------georadius---------------------
127.0.0.1:6379<span class="token operator">></span> GEORADIUS china:city 120 30 500 km withcoord withdist <span class="token comment" spellcheck="true"># 查询经纬度(120,30)坐标500km半径内的成员</span>
1<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"hangzhou"</span>
   2<span class="token punctuation">)</span> <span class="token string">"29.4151"</span>
   3<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"120.20000249147415"</span>
      2<span class="token punctuation">)</span> <span class="token string">"30.199999888333501"</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"shanghai"</span>
   2<span class="token punctuation">)</span> <span class="token string">"205.3611"</span>
   3<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"121.40000134706497"</span>
      2<span class="token punctuation">)</span> <span class="token string">"31.400000253193539"</span>

------------geohash---------------------------
127.0.0.1:6379<span class="token operator">></span> geohash china:city yichang shanghai <span class="token comment" spellcheck="true"># 获取成员经纬坐标的geohash表示</span>
1<span class="token punctuation">)</span> <span class="token string">"wmrjwbr5250"</span>
2<span class="token punctuation">)</span> <span class="token string">"wtw6ds0y300"</span>
</code></pre>
<h3 id="emsp-Hyperloglog-基数统计"><a href="#emsp-Hyperloglog-基数统计" class="headerlink" title="&emsp;Hyperloglog(基数统计)"></a>&emsp;Hyperloglog(基数统计)</h3><blockquote>
<p>Redis HyperLogLog 是用来做基数统计的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，<strong>计算基数所需的空间总是固定的、并且是很小的。</strong><br>花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。<br>因为 HyperLogLog <strong>只会根据输入元素来计算基数，而不会储存输入元素本身</strong>，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。<br>其底层使用string数据类型</p>
</blockquote>
<p><strong>什么是基数？</strong></p>
<blockquote>
<p><strong>数据集中不重复的元素的个数。</strong></p>
</blockquote>
<p><strong>应用场景</strong></p>
<p>网页的访问量（UV）：一个用户多次访问，也只能算作一个人。</p>
<blockquote>
<p>传统实现，存储用户的id,然后每次进行比较。当用户变多之后这种方式及其浪费空间，而我们的<strong>目的只是计数</strong>，<strong>Hyperloglog就能帮助我们利用最小的空间完成。</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><font color=red>PFADD key element1 [elememt2..]</font></td>
<td>添加指定元素到 HyperLogLog 中</td>
</tr>
<tr>
<td><font color=red>PFCOUNT key [key]</font></td>
<td>返回给定 HyperLogLog 的基数估算值。</td>
</tr>
<tr>
<td><font color=red>PFMERGE destkey sourcekey [sourcekey..]</font></td>
<td>将多个 HyperLogLog 合并为一个 HyperLogLog</td>
</tr>
</tbody></table>
<pre class=" language-bash"><code class="language-bash">----------PFADD--PFCOUNT---------------------
127.0.0.1:6379<span class="token operator">></span> PFADD myelemx a b c d e f g h i j k <span class="token comment" spellcheck="true"># 添加元素</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> <span class="token function">type</span> myelemx <span class="token comment" spellcheck="true"># hyperloglog底层使用String</span>
string
127.0.0.1:6379<span class="token operator">></span> PFCOUNT myelemx <span class="token comment" spellcheck="true"># 估算myelemx的基数</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 11
127.0.0.1:6379<span class="token operator">></span> PFADD myelemy i j k z m c b <span class="token function">v</span> p q s
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> PFCOUNT myelemy
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 11

----------------PFMERGE-----------------------
127.0.0.1:6379<span class="token operator">></span> PFMERGE myelemz myelemx myelemy <span class="token comment" spellcheck="true"># 合并myelemx和myelemy 成为myelemz</span>
OK
127.0.0.1:6379<span class="token operator">></span> PFCOUNT myelemz <span class="token comment" spellcheck="true"># 估算基数</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 17

</code></pre>
<p>虽然其底层使用String，但是get出来的值…</p>
<p><img src="https://img-blog.csdnimg.cn/20200901230125774.png#pic_center" alt=""></p>
<h3 id="emsp-BitMaps-位图"><a href="#emsp-BitMaps-位图" class="headerlink" title="&emsp;BitMaps(位图)"></a>&emsp;BitMaps(位图)</h3><blockquote>
<p><strong>使用位存储</strong>，信息状态只有 0 和 1<br>Bitmap是一串连续的2进制数字（0或1），每一位所在的位置为偏移(offset)，在bitmap上可执行AND,OR,XOR,NOT以及其它位操作。</p>
</blockquote>
<p><strong>应用场景</strong></p>
<p>签到统计、状态统计<br>|命令| 描述 |<br>|–|–|<br>| <font color=red> setbit key offset value</font>|  为指定key的offset位设置值|<br>| <font color=red> getbit key offset</font>|  获取offset位的值|<br>| <font color=red>bitcount key [start end] </font>|统计字符串被设置为1的bit数，也可以指定统计范围<strong>按字节</strong><br>| <font color=red> bitop operration destkey key[key..]</font>|对一个或多个保存二进制位的字符串 key 进行位元操作，并将结果保存到 destkey 上。  |<br>| <font color=red> BITPOS key bit [start] [end]    </font>| 返回字符串里面第一个被设置为1或者0的bit位。<strong>start和end只能按字节,不能按位</strong> |</p>
<pre class=" language-bash"><code class="language-bash">------------setbit--getbit--------------
127.0.0.1:6379<span class="token operator">></span> setbit sign 0 1 <span class="token comment" spellcheck="true"># 设置sign的第0位为 1 </span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1:6379<span class="token operator">></span> setbit sign 2 1 <span class="token comment" spellcheck="true"># 设置sign的第2位为 1  不设置默认 是0</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1:6379<span class="token operator">></span> setbit sign 3 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1:6379<span class="token operator">></span> setbit sign 5 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1:6379<span class="token operator">></span> <span class="token function">type</span> sign
string

127.0.0.1:6379<span class="token operator">></span> getbit sign 2 <span class="token comment" spellcheck="true"># 获取第2位的数值</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> getbit sign 3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1:6379<span class="token operator">></span> getbit sign 4 <span class="token comment" spellcheck="true"># 未设置默认是0</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0

-----------bitcount----------------------------
127.0.0.1:6379<span class="token operator">></span> BITCOUNT sign <span class="token comment" spellcheck="true"># 统计sign中为1的位数</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4

</code></pre>
<p><strong><strong>bitmaps的底层</strong></strong><br><img src="https://img-blog.csdnimg.cn/20200901230621645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>这样设置以后你能get到的值是：\xA2\x80，所以bitmaps是一串从<strong>左到右的二进制串</strong></p>
<h2 id="五、事务"><a href="#五、事务" class="headerlink" title="五、事务"></a>五、事务</h2><p><strong>Redis的</strong>单条命令<strong>是</strong>保证原子性<strong>的，但是</strong>redis事务<font color=red>不能</font>保证原子性****</p>
<blockquote>
<p>Redis事务：一组命令的集合。<br>事务中每条命令都会被序列化，执行过程中按顺序执行，不允许其他命令进行干扰。</p>
<ul>
<li><p>一次性</p>
</li>
<li><p>顺序性</p>
</li>
<li><p>排他性</p>
<hr>

<p><strong>1.Redis事务没有隔离级别的概念</strong> </p>
</li>
</ul>
<p><strong>2.Redis单条命令是保证原子性的，但是事务不保证原子性！</strong></p>
</blockquote>
<p>&emsp;&emsp;所以事务中的命令在加入时都没有被执行，直到提交时才会开始执行(Exec)一次性完成。</p>
<p>&emsp;&emsp;操作过程：<strong>开启事务</strong>(<strong>multi</strong>) &gt;&gt; <strong>命令入队</strong> &gt;&gt; <strong>执行事务</strong>(<strong>exec</strong>)</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> multi <span class="token comment" spellcheck="true"># 开启事务</span>
OK
127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> k1 v1 <span class="token comment" spellcheck="true"># 命令入队</span>
QUEUED
127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> k2 v2 <span class="token comment" spellcheck="true"># ..</span>
QUEUED
127.0.0.1:6379<span class="token operator">></span> get k1
QUEUED
127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> k3 v3
QUEUED
127.0.0.1:6379<span class="token operator">></span> keys *
QUEUED
127.0.0.1:6379<span class="token operator">></span> <span class="token function">exec</span> <span class="token comment" spellcheck="true"># 事务执行</span>
1<span class="token punctuation">)</span> OK
2<span class="token punctuation">)</span> OK
3<span class="token punctuation">)</span> <span class="token string">"v1"</span>
4<span class="token punctuation">)</span> OK
5<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">"k3"</span>
   2<span class="token punctuation">)</span> <span class="token string">"k2"</span>
   3<span class="token punctuation">)</span> <span class="token string">"k1"</span>
</code></pre>
<p><strong>取消事务(</strong>discurd<strong>)</strong></p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> multi
OK
127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> k1 v1
QUEUED
127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> k2 v2
QUEUED
127.0.0.1:6379<span class="token operator">></span> DISCARD <span class="token comment" spellcheck="true"># 放弃事务</span>
OK
127.0.0.1:6379<span class="token operator">></span> EXEC 
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR EXEC without MULTI <span class="token comment" spellcheck="true"># 当前未开启事务</span>
127.0.0.1:6379<span class="token operator">></span> get k1 <span class="token comment" spellcheck="true"># 被放弃事务中命令并未执行</span>
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre>
<h3 id="emsp-事务错误"><a href="#emsp-事务错误" class="headerlink" title="&emsp;事务错误"></a>&emsp;事务错误</h3><blockquote>
<p><font color=red>代码语法错误</font>（编译时异常）<strong>所有的命令都不执行</strong></p>
</blockquote>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> multi
OK
127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> k1 v1
QUEUED
127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> k2 v2
QUEUED
127.0.0.1:6379<span class="token operator">></span> error k1 <span class="token comment" spellcheck="true"># 这是一条语法错误命令</span>
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR unknown <span class="token function">command</span> <span class="token variable"><span class="token variable">`</span>error<span class="token variable">`</span></span>, with args beginning with: <span class="token variable"><span class="token variable">`</span>k1<span class="token variable">`</span></span>, <span class="token comment" spellcheck="true"># 会报错但是不影响后续命令入队 </span>
127.0.0.1:6379<span class="token operator">></span> get k2
QUEUED
127.0.0.1:6379<span class="token operator">></span> EXEC
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> EXECABORT Transaction discarded because of previous errors. <span class="token comment" spellcheck="true"># 执行报错</span>
127.0.0.1:6379<span class="token operator">></span> get k1 
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 其他命令并没有被执行</span>

</code></pre>
<blockquote>
<p><font color=red>代码逻辑错误</font> (运行时异常) <strong>**其他命令可以正常执行</strong> <strong>&gt;&gt; **不保证事务原子性</strong></p>
</blockquote>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> multi
OK
127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> k1 v1
QUEUED
127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> k2 v2
QUEUED
127.0.0.1:6379<span class="token operator">></span> INCR k1 <span class="token comment" spellcheck="true"># 这条命令逻辑错误（对字符串进行增量）</span>
QUEUED
127.0.0.1:6379<span class="token operator">></span> get k2
QUEUED
127.0.0.1:6379<span class="token operator">></span> <span class="token function">exec</span>
1<span class="token punctuation">)</span> OK
2<span class="token punctuation">)</span> OK
3<span class="token punctuation">)</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR value is not an integer or out of range <span class="token comment" spellcheck="true"># 运行时报错</span>
4<span class="token punctuation">)</span> <span class="token string">"v2"</span> <span class="token comment" spellcheck="true"># 其他命令正常执行</span>
</code></pre>
<h3 id="emsp-监控"><a href="#emsp-监控" class="headerlink" title="&emsp;监控"></a>&emsp;监控</h3><p><strong>悲观锁：</strong></p>
<ul>
<li>很悲观，认为什么时候都会出现问题，<strong>无论做什么都会加锁</strong></li>
</ul>
<p><strong>乐观锁：</strong></p>
<ul>
<li>很乐观，认为什么时候都不会出现问题，所以不会上锁！<strong>更新数据的时候去判断一下，在此期间是否有人修改过这个数据</strong></li>
<li><strong>获取version</strong></li>
<li><strong>更新的时候比较version</strong></li>
</ul>
<p>使用<font color=red>watch key</font>监控指定数据，相当于乐观锁加锁。</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> money 100 <span class="token comment" spellcheck="true"># 设置余额:100</span>
OK
127.0.0.1:6379<span class="token operator">></span> <span class="token keyword">set</span> use 0 <span class="token comment" spellcheck="true"># 支出使用:0</span>
OK
127.0.0.1:6379<span class="token operator">></span> <span class="token function">watch</span> money <span class="token comment" spellcheck="true"># 监视money (上锁)</span>
OK
127.0.0.1:6379<span class="token operator">></span> multi
OK
127.0.0.1:6379<span class="token operator">></span> DECRBY money 20
QUEUED
127.0.0.1:6379<span class="token operator">></span> INCRBY use 20
QUEUED
127.0.0.1:6379<span class="token operator">></span> <span class="token function">exec</span> <span class="token comment" spellcheck="true"># 监视值没有被中途修改，事务正常执行</span>
1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 80
2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 20
</code></pre>
<blockquote>
<p>线程插队，修改监视值。</p>
</blockquote>
<p>我们启动另外一个客户端模拟插队线程。</p>
<p>线程1：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> <span class="token function">watch</span> money <span class="token comment" spellcheck="true"># money上锁</span>
OK
127.0.0.1:6379<span class="token operator">></span> multi
OK
127.0.0.1:6379<span class="token operator">></span> DECRBY money 20
QUEUED
127.0.0.1:6379<span class="token operator">></span> INCRBY use 20
QUEUED
127.0.0.1:6379<span class="token operator">></span>     <span class="token comment" spellcheck="true"># 此时事务并没有执行</span>
</code></pre>
<p>模拟线程插队，线程2:</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> INCRBY money 500 <span class="token comment" spellcheck="true"># 修改了线程一中监视的money</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 600
</code></pre>
<p>回到线程1，执行事务：</p>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> EXEC 
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 没有结果，说明事务执行失败</span>

127.0.0.1:6379<span class="token operator">></span> get money <span class="token comment" spellcheck="true"># 线程2 修改生效</span>
<span class="token string">"600"</span>
127.0.0.1:6379<span class="token operator">></span> get use <span class="token comment" spellcheck="true"># 线程1事务执行失败，数值没有被修改</span>
<span class="token string">"0"</span>

</code></pre>
<blockquote>
<p>解锁获取最新值，然后再加锁进行事务。<br><font color=red>unwatch</font>进行解锁。</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash">127.0.0.1:6379<span class="token operator">></span> UNWATCH <span class="token comment" spellcheck="true"># 解锁</span>
OK
127.0.0.1:6379<span class="token operator">></span> WATCH money
OK
127.0.0.1:6379<span class="token operator">></span> multi <span class="token comment" spellcheck="true"># 重新进行事务</span>
OK
127.0.0.1:6379<span class="token operator">></span> DECRBY money 200
QUEUED
127.0.0.1:6379<span class="token operator">></span> INCRBY use 200
QUEUED
127.0.0.1:6379<span class="token operator">></span> <span class="token function">exec</span>
1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 400
2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 200
</code></pre>
<p><strong>注意：每次提交执行exec后都会自动释放锁，不管是否成功</strong></p>
<h2 id="六、Jedis"><a href="#六、Jedis" class="headerlink" title="六、Jedis"></a>六、Jedis</h2><p><strong>使用Java来操作Redis</strong>，<strong>Jedis</strong>是Redis官方推荐使用的<strong>Java连接redis的客户端</strong>。</p>
<p>1.依赖导入:jedis、fastjson</p>
<pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>导入jredis的包<span class="token operator">--</span><span class="token operator">></span>
<span class="token operator">&lt;</span>dependency<span class="token operator">></span>
    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>redis<span class="token punctuation">.</span>clients<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>
    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>jedis<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>
    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">3.2</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span>fastjson<span class="token operator">--</span><span class="token operator">></span>
<span class="token operator">&lt;</span>dependency<span class="token operator">></span>
    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>com<span class="token punctuation">.</span>alibaba<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>
    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>fastjson<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>
    <span class="token operator">&lt;</span>version<span class="token operator">></span><span class="token number">1.2</span><span class="token punctuation">.</span><span class="token number">70</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>
</code></pre>
<p>2.连接数据库</p>
<blockquote>
<p>连接远程：<br>开放端口6379</p>
</blockquote>
<pre class=" language-bash"><code class="language-bash">firewall-cmd --zone<span class="token operator">=</span>public --add-port<span class="token operator">=</span>6379/tcp --permanent
</code></pre>
<blockquote>
<p>需要修改配置文件：<br>修改bind IP，默认是127.0.0.1 也就是localhost,只有本机可用。<br>修改为0.0.0.0 或者 本机的ip地址。</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200901233305692.png#pic_center" alt=""></p>
<blockquote>
<p>关闭保护模式<br>默认是yes,修改为no</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20200901233332404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>然后以此配置文件启动redis-server</p>
<p><strong>Java中操作Redis就需要 一个Jedis对象</strong>，创建Jedis对象，需要主机号和端口号作为参数。</p>
<p>其中的API与使用Redis原生的命令是一样的。</p>
<p><strong>事务：</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestTransaction</span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Jedis jedis <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jedis</span><span class="token punctuation">(</span><span class="token string">"192.168.167.15"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        JSONObject jsonObject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JSONObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"sakura"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jsonObject<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        String info <span class="token operator">=</span> jsonObject<span class="token punctuation">.</span><span class="token function">toJSONString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 开启事务</span>
        Transaction transaction <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            transaction<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"user1"</span><span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>
            transaction<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"user2"</span><span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 执行事务</span>
            transaction<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 如果出错则放弃事务</span>
            transaction<span class="token punctuation">.</span><span class="token function">discard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"user1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"user2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment" spellcheck="true">// 关闭连接</span>
            jedis<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre>
<h2 id="七、SpringBoot整合Redis"><a href="#七、SpringBoot整合Redis" class="headerlink" title="七、SpringBoot整合Redis"></a>七、SpringBoot整合Redis</h2><p>需要的依赖项,在创建项目时选择，或者手动加入。</p>
<pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>dependency<span class="token operator">></span>
    <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>
    <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>data<span class="token operator">-</span>redis<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">></span>
</code></pre>
<p><strong>springboot 2.x后 ，原来使用的 Jedis 被 lettuce 替换。</strong></p>
<ul>
<li><p>Jedis：采用直连，多线程操作不安全。如果要避免不安全，使用jedis pool连接池！更像BIO模式</p>
</li>
<li><p>Lettuce：底层采用Netty,实例可以在多个线程中共享，不存在线程不安全的情况！可以减少线程数据了，更像NIO模式<br><img src="https://img-blog.csdnimg.cn/20200901233830376.png#pic_center" alt=""></p>
</li>
</ul>
<br>

<p>&emsp;&emsp;我们在学习SpringBoot自动配置的原理时，整合一个组件并进行配置一定会有一个<strong>自动配置类RedisAutoConfiguration</strong>,并且在spring.factories中也一定能找到这个类的完全限定名。Redis也不例外。</p>
<p><img src="https://img-blog.csdnimg.cn/20200901233902657.png#pic_center" alt=""><br>那么就一定还存在一个<strong>RedisProperties类</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200901234029365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>&emsp;&emsp;之前我们说SpringBoot2.x后默认使用Lettuce来替换Jedis，现在我们就能来验证了。</p>
<p>先看Jedis:</p>
<p><img src="https://img-blog.csdnimg.cn/20200901234053505.png#pic_center" alt=""><br>@ConditionalOnClass注解中有两个类是默认不存在的，所以Jedis是无法生效的</p>
<p>然后再看Lettuce：<br><img src="https://img-blog.csdnimg.cn/20200901234125641.png#pic_center" alt=""><br>完美生效。</p>
<p>现在我们回到RedisAutoConfiguration<br><img src="https://img-blog.csdnimg.cn/20200901234148706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>只有两个简单的Bean</p>
<ul>
<li>RedisTemplate</li>
<li>StringRedisTemplate</li>
</ul>
<p>&emsp;&emsp;当看到xxTemplate时可以对比RestTemplat、SqlSessionTemplate,通过使用这些Template来间接操作组件。那么这俩也不会例外。分别用于操作Redis和Redis中的String数据类型。</p>
<p><strong>在RedisTemplate上也有一个条件注解，说明我们是可以对其进行定制化的</strong></p>
<p>说完这些，我们需要知道如何编写配置文件然后连接Redis，就需要阅读RedisProperties</p>
<p><img src="https://img-blog.csdnimg.cn/20200901234320278.png#pic_center" alt=""><br>这是一些基本的配置属性。<br><img src="https://img-blog.csdnimg.cn/2020090123445044.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>还有一些连接池相关的配置。注意使用时一定使用<strong>Lettuce的连接池。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200901234512739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>配置文件:(基本不用写)</p>
<pre class=" language-java"><code class="language-java">spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>host<span class="token operator">=</span><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span>
spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>port<span class="token operator">=</span><span class="token number">6379</span>
# 以上俩个属性都有默认值 可以省略

# 默认使用 db0
spring<span class="token punctuation">.</span>redis<span class="token punctuation">.</span>database<span class="token operator">=</span><span class="token number">0</span>
</code></pre>
<p>测试使用：</p>
<p>1.我们说过现在操作Redis需要用到<strong>RedisTemplate</strong>，所以需要自动注入。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span>
RedisTemplate redisTemplate<span class="token punctuation">;</span>
</code></pre>
<p>2.使用RedisTemplate<br><img src="https://img-blog.csdnimg.cn/20200901234642170.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>在操作Redis中数据时，需要先通过opsForxxx()方法来获取对应的Operations,然后才可以操作数据。</p>
<p>3.以ValueOperations（操作String）为例<br><img src="https://img-blog.csdnimg.cn/20200901234730723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span>
RedisTemplate redisTemplate<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Test</span>
<span class="token keyword">void</span> <span class="token function">contextLoads</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true">// 获取Redis连接对象</span>
   RedisConnection connection <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">getConnectionFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true">// 清空数据库</span>
   connection<span class="token punctuation">.</span><span class="token function">flushDb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>redisTemplate<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   ValueOperations operations <span class="token operator">=</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true">// set</span>
   operations<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"sakura"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true">// get</span>
   System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>operations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true">// 事务支持开启</span>
   redisTemplate<span class="token punctuation">.</span><span class="token function">setEnableTransactionSupport</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   redisTemplate<span class="token punctuation">.</span><span class="token function">multi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">try</span> <span class="token punctuation">{</span>
      operations<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>operations<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 事务执行</span>
      redisTemplate<span class="token punctuation">.</span><span class="token function">exec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment" spellcheck="true">// 放弃事务</span>
      redisTemplate<span class="token punctuation">.</span><span class="token function">discard</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
      <span class="token comment" spellcheck="true">// 关闭连接</span>
      connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>此时我们回到Redis查看数据时候，惊奇发现全是乱码，可是程序中可以正常输出：<br><img src="https://img-blog.csdnimg.cn/20200901234824965.png#pic_center" alt=""><br>这时候就关系到存储<strong>对象的序列化问题</strong>，在网络中传输的对象也是一样需要序列化，否者就全是乱码。</p>
<p>我们转到看那个默认的RedisTemplate内部什么样子：</p>
<p><img src="https://img-blog.csdnimg.cn/20200901234910748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>在最开始就能看到几个关于序列化的参数。</p>
<p>默认的序列化器是采用JDK序列化器<br><img src="https://img-blog.csdnimg.cn/20200901234935780.png#pic_center" alt=""><br>而默认的RedisTemplate中的所有序列化器都是使用这个序列化器</p>
<p><img src="https://img-blog.csdnimg.cn/20200901235012612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>后续我们定制RedisTemplate就可以对其进行修改。</p>
<p><strong><font color=red>RedisSerializer</font></strong>提供了很多种序列化方案：</p>
<ul>
<li>我们可以直接调用RedisSerializer的方法来返回序列化器，然后set<br><img src="https://img-blog.csdnimg.cn/20200901235149514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></li>
</ul>
<ul>
<li>也可以自己new 相应的实现类，然后set</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200901235219125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>定制RedisTemplate的模板：</strong></p>
<p>我们创建一个Bean加入容器，就会触发RedisTemplate上的条件注解使默认的RedisTemplate失效。</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">{</span>

   <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span>RedisConnectionFactory redisConnectionFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> UnknownHostException <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">// 将template 泛型设置为 &lt;String, Object></span>
        RedisTemplate<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> template <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// 连接工厂，不必修改</span>
        template<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">/*
         * 序列化设置
         */</span>
        <span class="token comment" spellcheck="true">// key、hash的key 采用 String序列化方式</span>
        template<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span>RedisSerializer<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        template<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span>RedisSerializer<span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment" spellcheck="true">// value、hash的value 采用 Jackson 序列化方式</span>
        template<span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span>RedisSerializer<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        template<span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span>RedisSerializer<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        template<span class="token punctuation">.</span><span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> template<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p><strong>这样一来，只要实体类进行了序列化，我们存什么都不会有乱码的担忧了。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/202009012353448.png#pic_center" alt=""></p>
<h2 id="八、自定义Redis工具类"><a href="#八、自定义Redis工具类" class="headerlink" title="八、自定义Redis工具类"></a>八、自定义Redis工具类</h2><p>&emsp;&emsp;使用<strong>RedisTemplate</strong>需要频繁调用.<strong>opForxxx</strong>然后才能进行对应的操作，这样使用起来代码效率低下，工作中一般不会这样使用，而是<strong>将这些常用的公共API抽取出来封装成为一个工具类</strong>，然后直接使用工具类来间接操作Redis,不但效率高并且易用。</p>
<p>工具类参考博客：</p>
<p><a href="https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html、" target="_blank" rel="noopener">https://www.cnblogs.com/zeng1994/p/03303c805731afc9aa9c60dbbd32a323.html、</a></p>
<p><a href="https://www.cnblogs.com/zhzhlong/p/11434284.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhzhlong/p/11434284.html</a></p>
<h2 id="九、Redis-conf"><a href="#九、Redis-conf" class="headerlink" title="九、Redis.conf"></a>九、Redis.conf</h2><p>1.容量单位不区分大小写，<strong>G和GB有区别</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200901235729105.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>2.可以使用 include 组合多个配置问题<br><img src="https://img-blog.csdnimg.cn/20200901235749257.png#pic_center" alt=""><br>3.网络配置</p>
<p><img src="https://img-blog.csdnimg.cn/20200901235811299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>4.日志输出级别<br><img src="https://img-blog.csdnimg.cn/20200901235830866.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>6.日志输出文件</p>
<p><img src="https://img-blog.csdnimg.cn/20200901235848607.png#pic_center" alt=""><br>6.持久化规则</p>
<blockquote>
<p>由于Redis是基于内存的数据库，需要将数据由内存持久化到文件中<br>持久化方式：</p>
<ul>
<li>RDB</li>
<li>AOF</li>
</ul>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/2020090200002178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>7.RDB文件相关</p>
<p><img src="https://img-blog.csdnimg.cn/20200902000050954.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><img src="https://img-blog.csdnimg.cn/20200902000121926.png#pic_center" alt=""><br>8.关于主从复制，稍后再提<br><img src="https://img-blog.csdnimg.cn/20200902000140577.png#pic_center" alt=""><br>9.Security模块中进行密码设置<br><img src="https://img-blog.csdnimg.cn/20200902000159764.png#pic_center" alt=""><br>10.客户端连接相关</p>
<pre class=" language-java"><code class="language-java">maxclients <span class="token number">10000</span>  最大客户端数量
maxmemory <span class="token operator">&lt;</span>bytes<span class="token operator">></span> 最大内存限制
maxmemory<span class="token operator">-</span>policy noeviction # 内存达到限制值的处理策略
</code></pre>
<p>redis 中的默认的过期策略是** volatile-lru **。</p>
<p><strong>设置方式</strong></p>
<pre class=" language-bash"><code class="language-bash">config <span class="token keyword">set</span> maxmemory-policy volatile-lru 
</code></pre>
<p><strong><strong>maxmemory-policy 六种方式</strong></strong></p>
<ul>
<li>1、<font color=red><strong>volatile-lru</font></strong>：**只对设置了过期时间的key进行LRU（默认值）</li>
<li>2、<font color=red><strong>allkeys-lru</strong> </font>： 删除lru算法的key</li>
<li>3、<font color=red><strong>volatile-random</font></strong>：**随机删除即将过期key</li>
<li>4、<font color=red><strong>allkeys-random</font></strong>：**随机删除</li>
<li>5、<font color=red><strong>volatile-ttl</font></strong> ： 删除即将过期的</li>
<li>6、<font color=red><strong>noeviction</font></strong> ： 永不过期，返回错误</li>
</ul>
<p>11.AOF相关部分<br><img src="https://img-blog.csdnimg.cn/2020090200073065.png#pic_center" alt=""><br><img src="https://img-blog.csdnimg.cn/20200902000738609.png#pic_center" alt=""></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>事务</tag>
        <tag>jedis</tag>
        <tag>springboot整合</tag>
        <tag>redis.conf</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL内连接和外连接的区别</title>
    <url>/2020/08/22/SQL%E4%B8%AD%E7%9A%84%E5%B7%A6%E8%BF%9E%E6%8E%A5%E4%B8%8E%E5%8F%B3%E8%BF%9E%E6%8E%A5,%E5%86%85%E8%BF%9E%E6%8E%A5%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<p><strong>例子，相信你一看就明白，不需要多说<br>A表(a1,b1,c1) B表(a2,b2)</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200823002746459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><img src="https://img-blog.csdnimg.cn/20200823002801818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>左连接：<br>select A.<em>,B.</em> from A left outer join B on(A.a1=B.a2)<br>结果是:</strong><br><img src="https://img-blog.csdnimg.cn/20200823002839691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>右连接：<br>select A.<em>,B.</em> from A right outer join B on(A.a1=B.a2)<br>结果是:</strong><br><img src="https://img-blog.csdnimg.cn/20200823002901758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>内连接：<br>自然联结：SELECT * FROM a, b where a.a1=b.a2，这两种写法一样<br>（内连接和自然联结一样，一般情况下都使用自然联结）</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200823002934343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<p><strong>结论：</strong></p>
<p><strong><font color=red>左连接：左边有的，右边没有的为null（A right outer join B）<br><br>右连接：左边没有的，右边有的为null（A left outer join B）<br><br>内连接：显示左边右边共有的（A inner join B）</font></strong></p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>内连接</tag>
        <tag>外连接</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue笔记一</title>
    <url>/2020/08/23/Vue1/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<h2 id="Vue概述"><a href="#Vue概述" class="headerlink" title="Vue概述"></a>Vue概述</h2><p> &emsp;&emsp;Vue (读音/vju/, 类似于view)是一套用于构建用户界面的<font color=red><strong>渐进式框架</strong></font>，发布于2014年2月。与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。<font color=red><strong>Vue的核心库只关注视图层</strong></font>，不仅易于上手，还便于与第三方库(如: <font color=red><strong>vue-router: 跳转，vue-resource: 通信，vuex:管理</strong></font>)或既有项目整合。</p>
<h2 id="前端知识体系"><a href="#前端知识体系" class="headerlink" title="前端知识体系"></a>前端知识体系</h2><p>&emsp;&emsp; 想要成为真正的“互联网Java全栈工程师”还有很长的一段路要走，其中“我大前端”是绕不开的一门必修课。本阶段课程的主要目的就是带领我Java后台程序员认识前端、了解前端、掌握前端,为实现成为“互联网Java全栈工程师”再向前迈进一步。</p>
<h2 id="前端三要素"><a href="#前端三要素" class="headerlink" title="前端三要素"></a>前端三要素</h2><p>●HTML (结构) :超文本标记语言(Hyper Text Markup Language) ，决定网页的结构和内容<br>●CSS (表现) :层叠样式表(Cascading Style sheets) ，设定网页的表现样式<br>●JavaScript (行为) :是一种弱类型脚本语言，其源代码不需经过编译，而是由浏览器解释运行,用于控制网页的行为</p>
<h2 id="表现层（CSS）"><a href="#表现层（CSS）" class="headerlink" title="表现层（CSS）"></a>表现层（CSS）</h2><p>  &emsp;&emsp;CSS层叠样式表是<font color=red><em>一门标记语言</em></font>,并不是编程语言，因此不可以自定义变量，不可以引用等，换句话说就是不具备任何语法支持，它主要缺陷如下:<br>●语法不够强大，比如无法嵌套书写，导致模块化开发中需要写很多重复的选择器;<br>●没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护;<br>这就导致了我们在工作中无端增加了许多工作量。为了解决这个问题，前端开发人员会使用一种称之为<font color=red><strong>[CSS预处理器]</strong></font>的工具，提供CSS缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了前端在样式上的开发效率。（例如页面在不同的时候有不同的需求，淘宝在双11和618的样式就会不一样）</p>
<h2 id="CSS预处理器"><a href="#CSS预处理器" class="headerlink" title="CSS预处理器"></a>CSS预处理器</h2><p>  &emsp;&emsp;CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的<font color=red>编程语言</font>，为CSS增加了一些编程的特性，将CSS作为目标生成文件,然后开发者就只要使用这种语言进行CSS的编码工作。转化成通俗易懂的话来说就是“_<font color=red>用一种专门的编程语言,进行Web页面样式设计，再通过编译器转化为正常的CSS文件，以供项目使用</font>_”<br>常用的CSS预处理器有哪些<br>●SASS:基于Ruby,通过服务端处理，功能强大。解析效率高。需要学习Ruby语言，上手难度高于LESS。<br>●LESS:基于NodeJS,通过客户端处理，使用简单。功能比SASS简单，解析效率也低于SASS,但在实际开发中足够了，所以我们后台人员如果需要的话，建议使用LESS。</p>
<h2 id="JavaScript框架"><a href="#JavaScript框架" class="headerlink" title="JavaScript框架"></a>JavaScript框架</h2><p>●<font color=red>jQuery</font>: 大家熟知的JavaScript框架，优点是简化了DOM操作，缺点是DOM操作太频繁,影响前端性能;在前端眼里使用它仅仅是为了兼容IE6、7、8;<br>●<font color=red>Angular</font>: Google收购的前端框架，由一群Java程序员开发，其特点是将后台的MVC模式搬到了前端并增加了模块化开发的理念，与微软合作，采用TypeScript语法开发;对后台程序员友好，对前端程序员不太友好;最大的缺点是版本迭代不合理(如: 1代-&gt; 2代，除了名字，基本就是两个东西;截止发表博客时已推出了Angular6)<br>●<font color=red>React</font>: Facebook出品，一款高性能的JS前端框架;特点是提出了新概念[虚拟DOM]用于<br>减少真实DOM操作，在内存中模拟DOM操作，有效的提升了前端渲染效率;缺点是使用复<br>杂，因为需要额外学习一门[JSX] 语言;<br>●<font color=red>Vue</font>:一款渐进式JavaScript框架，所谓渐进式就是逐步实现新特性的意思，如实现模块化开发、路由、状态管理等新特性。其特点是综合了Angular (模块化)和React (虚拟DOM)的优点;<br>●<font color=red>Axios</font> :前端通信框架;因为Vue 的边界很明确，就是为了处理DOM,所以并不具备通信能<br>力，此时就需要额外使用一个<font color=blue>通信框架与服务器交互</font>;当然也可以直接选择使用jQuery提供的AJAX通信功能;<br>前端三大框架：Angular、React、Vue</p>
<h2 id="UI框架"><a href="#UI框架" class="headerlink" title="UI框架"></a>UI框架</h2><p>●Ant-Design:阿里巴巴出品，基于React的UI框架<br>●<font color=red>ElementUI、 iview、 ice: 饿了么出品，基于Vue的UI框架</font><br>●Bootstrap: Twitter推出的一个用于前端开发的开源工具包<br>●AmazeUI:又叫”妹子UI”，一款HTML5跨屏前端框架.<br>JavaScript 构建工具<br>●Babel: JS编译工具，主要用于浏览器不支持的ES新特性，比如用于编译TypeScript<br>●WebPack: 模块打包器，主要作用是打包、压缩、合并及按序加载<br>注：以上知识点将WebApp开发所需技能全部梳理完毕</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue笔记三</title>
    <url>/2020/08/25/Vue%E7%AC%94%E8%AE%B0%E4%B8%89/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<h2 id="Axios异步通信-通信框架"><a href="#Axios异步通信-通信框架" class="headerlink" title="Axios异步通信(通信框架)"></a>Axios异步通信(通信框架)</h2><p>&emsp;&emsp;Axios是一个开源的可以用在浏览器端和NodeJS 的异步通信框架，它的主要作用就是<font color=red>实现AJAX异步通信</font>，其功能特点如下:<br><strong><em>●从浏览器中创建XMLHttpRequests<br>●从node.js创建http请求<br>●支持Promise API [JS中链式编程]<br>●拦截请求和响应<br>●转换请求数据和响应数据<br>●取消请求<br>●自动转换JSON数据<br>●客户端支持防御XSRF (跨站请求伪造)</em></strong></p>
<blockquote>
<p>GitHub: <a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a> axios/axios<br>中文文档: <a href="http://www.axios-js.com/" target="_blank" rel="noopener">http://www.axios-js.com/</a></p>
</blockquote>
<h2 id="为什么要使用Axios"><a href="#为什么要使用Axios" class="headerlink" title="为什么要使用Axios"></a>为什么要使用Axios</h2><p>&emsp;&emsp;由于Vue.js是一个视图层框架且作者(尤雨溪) 严格准守SoC (关注度分离原则)，所以Vue.js并不包含AJAX的通信功能，<font color=red>为了解决通信问题</font>，作者单独开发了一个名为vue-resource的插件，不过在进入2.0 版本以后停止了对该插件的维护并推荐了Axios 框架。少用jQuery，因为它操作Dom太频繁!</p>
<h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><blockquote>
<p>官方文档: <a href="https://cn.vuejs.org/v2/guide/instance.html#生" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/instance.html#生</a><br>命周期图示</p>
</blockquote>
<p>&emsp;&emsp;Vue实例有一个完整的生命周期，也就是从<font color=orgran><strong>开始创建、初始化数据、编译模板、挂载DOM、渲染→更新→渲染、卸载</strong></font>等一系列过程，我们称这是Vue的生命周期。通俗说就是Vue实例从创建到销毁的过程，就是生命周期。<br>&emsp;&emsp;在Vue的整个生命周期中，它提供了一系列的事件，可以让我们在事件触发时注册JS方法,可以让我们用自己注册的JS方法控制整个大局，在这些事件响应方法中的this直接指向的是Vue的实例。</p>
<p><strong>代码 初探axios<br>先建立一个data.json</strong></p>
<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>
  <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cqh"</span><span class="token punctuation">,</span>
  <span class="token property">"age"</span><span class="token operator">:</span> <span class="token string">"18"</span><span class="token punctuation">,</span>
  <span class="token property">"sex"</span><span class="token operator">:</span> <span class="token string">"男"</span><span class="token punctuation">,</span>
  <span class="token property">"url"</span><span class="token operator">:</span><span class="token string">"https://www.baidu.com"</span><span class="token punctuation">,</span>
  <span class="token property">"address"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"street"</span><span class="token operator">:</span> <span class="token string">"缇香郡"</span><span class="token punctuation">,</span>
    <span class="token property">"city"</span><span class="token operator">:</span> <span class="token string">"宁波"</span><span class="token punctuation">,</span>
    <span class="token property">"country"</span><span class="token operator">:</span> <span class="token string">"中国"</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token property">"links"</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"bilibili"</span><span class="token punctuation">,</span>
      <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://www.bilibili.com"</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"baidu"</span><span class="token punctuation">,</span>
      <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://www.baidu.com"</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
      <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"cqh video"</span><span class="token punctuation">,</span>
      <span class="token property">"url"</span><span class="token operator">:</span> <span class="token string">"https://www.4399.com"</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span></code></pre>
<p><strong>demo07.html</strong></p>
<pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
    <span class="token comment" spellcheck="true">&lt;!--在线CDN--></span>
    <span class="token comment" spellcheck="true">&lt;!--1.导入vue.js--></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
    <span class="token comment" spellcheck="true">&lt;!--导入axios--></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.bootcdn.net/ajax/libs/axios/0.19.2/axios.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span>{{info.name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">v-bind:</span>href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>info.url<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>点我到百度链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>
        <span class="token comment" spellcheck="true">//和data: 不同 属性：vm</span>
        <span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">{</span>
                info<span class="token punctuation">:</span> <span class="token punctuation">{</span>
                    name<span class="token punctuation">:</span><span class="token keyword">null</span><span class="token punctuation">,</span>
                    url<span class="token punctuation">:</span><span class="token keyword">null</span><span class="token punctuation">,</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token function">mounted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//钩子函数 链式编程 ES6新特性</span>
            axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">"../data.json"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>info<span class="token operator">=</span>response<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<h2 id="什么是计算属性？（VUE相比Angular和React的特性）"><a href="#什么是计算属性？（VUE相比Angular和React的特性）" class="headerlink" title="什么是计算属性？（VUE相比Angular和React的特性）"></a>什么是计算属性？（VUE相比Angular和React的特性）</h2><p>&emsp;&emsp;计算属性的重点突出在属性两个字上(属性是名词)，首先它是个属性其次这个属性有计算的能力(计算是动词)，这里的计算就是个函数;简单点说，它就是一个能够将计算结果缓存起来的属性(<font color=red>将行为转化成了静态的属性</font>)，仅此而已;<font color=red>可以想象为缓存!</font></p>
<br>
<br>


<p><strong>代码 demo08.html 计算属性了解</strong></p>
<pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">></span></span>Title<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">></span></span>
    <span class="token comment" spellcheck="true">&lt;!--在线CDN--></span>
    <span class="token comment" spellcheck="true">&lt;!--1.导入vue.js--></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>c1:{{getTime()}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span>c2:{{getTime2}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>
        data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
            message<span class="token punctuation">:</span> <span class="token string">"hello cqh"</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
            getTime<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        <span class="token comment" spellcheck="true">//计算属性</span>
        computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>
            getTime2<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">;</span>
                <span class="token keyword">return</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>
<p><font color=red><strong>结论:</strong></font><br> 调用方法时，每次都需要进行计算，既然有计算过程则必定产生系统开销，那如果这个结果是不经常变化的呢?此时就可以考虑将这个结果缓存起来，采用计算属性可以很方便的做到这一点,<strong><font color=red>计算属性的主要特性就是为了将不经常变化的计算结果进行缓存，以节约我们的系统开销;</font></strong></p>
<h2 id="内容分发"><a href="#内容分发" class="headerlink" title="内容分发"></a>内容分发</h2><p>&emsp;&emsp;在Vue.js中我们使用 元素作为承载分发内容的出口，作者称其为插槽，可以应用在组合组件的场景中;<br>这里穿插以下vue的语法缩写<br><strong><font color=blue>v:bind: 可以缩写为一个:<br>v-on: 可以缩写为一个@</font></strong></p>
<p>代码demo9 插槽初体验</p>
<pre class=" language-html"><code class="language-html"><span class="token doctype">&lt;!DOCTYPE html></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>UTF-8<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token comment" spellcheck="true">&lt;!--1.导入vue.js--></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>todo</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>todo-title</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>todo-title<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">v-bind:</span>title</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>title<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>todo-title</span><span class="token punctuation">></span></span>
        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>todo-items</span> <span class="token attr-name">slot</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>todo-items<span class="token punctuation">"</span></span> <span class="token attr-name">v-for</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item in todoItems<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">v-bind:</span>item</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>todo-items</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>todo</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    <span class="token comment" spellcheck="true">//slot 插槽 这个组件要定义在前面不然出不来数据</span>
    Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">"todo"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        template<span class="token punctuation">:</span> <span class="token string">'&lt;div>\
                &lt;slot name="todo-title">&lt;/slot>\
                &lt;ul>\
                &lt;slot name="todo-items">&lt;/slot>\
                &lt;/ul>\
                &lt;div>'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">"todo-title"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//属性</span>
        props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        template<span class="token punctuation">:</span> <span class="token string">'&lt;div>{{title}}&lt;/div>'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">"todo-items"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        props<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'item'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        template<span class="token punctuation">:</span> <span class="token string">'&lt;li>{{item}}&lt;/li>'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>
        data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//标题</span>
            title<span class="token punctuation">:</span> <span class="token string">"图书馆系列图书"</span><span class="token punctuation">,</span>
            <span class="token comment" spellcheck="true">//列表</span>
            todoItems<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'三国演义'</span><span class="token punctuation">,</span> <span class="token string">'红楼梦'</span><span class="token punctuation">,</span> <span class="token string">'西游记'</span><span class="token punctuation">,</span> <span class="token string">'水浒传'</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span>
</code></pre>
<h2 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h2><p>&emsp;&emsp;通过以上代码不难发现，数据项在Vue的实例中，但删除操作要在组件中完成，那么组件如何才能删除Vue实例中的数据呢?此时就涉及到参数传递与事件分发了，Vue为我们提供了自定义事件的功能很好的帮助我们解决了这个问题;使用<strong><font color=red>this.$emit(‘自定义事件名’,参数)</font></strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200825013100892.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="自定义事件图解"></p>
<p><strong>代码 demo09-1 自定义组件</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span>
<span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>head<span class="token operator">></span>
    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token number">1</span><span class="token punctuation">.</span>导入vue<span class="token punctuation">.</span>js<span class="token operator">--</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>
<span class="token operator">&lt;</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>todo<span class="token operator">></span>
        <span class="token operator">&lt;</span>todo<span class="token operator">-</span>title slot<span class="token operator">=</span><span class="token string">"todo-title"</span> v<span class="token operator">-</span>bind<span class="token operator">:</span>title<span class="token operator">=</span><span class="token string">"title"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>todo<span class="token operator">-</span>title<span class="token operator">></span>
        <span class="token operator">&lt;</span>todo<span class="token operator">-</span>items slot<span class="token operator">=</span><span class="token string">"todo-items"</span>
                    v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"(item,i) in todoItems"</span>
                    v<span class="token operator">-</span>bind<span class="token operator">:</span>item<span class="token operator">=</span><span class="token string">"item"</span> v<span class="token operator">-</span>bind<span class="token operator">:</span>index<span class="token operator">=</span><span class="token string">"i"</span>
                    v<span class="token operator">-</span>on<span class="token operator">:</span>remove<span class="token operator">=</span><span class="token string">"removeItem(i)"</span><span class="token operator">></span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>todo<span class="token operator">-</span>items<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>todo<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span>script<span class="token operator">></span>
    <span class="token comment" spellcheck="true">//slot 插槽 这个组件要定义在前面不然出不来数据</span>
    Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">"todo"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        template<span class="token operator">:</span> <span class="token string">'&lt;div>\
                &lt;slot name="todo-title">&lt;/slot>\
                &lt;ul>\
                &lt;slot name="todo-items">&lt;/slot>\
                &lt;/ul>\
                &lt;div>'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">"todo-title"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token comment" spellcheck="true">//属性</span>
        props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'title'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        template<span class="token operator">:</span> <span class="token string">'&lt;div>{{title}}&lt;/div>'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">"todo-items"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'item'</span><span class="token punctuation">,</span> <span class="token string">'index'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        template<span class="token operator">:</span> <span class="token string">'&lt;li>{{index}}-{{item}}&lt;button style="margin: 5px" @click="remove">删除&lt;/button>&lt;/li>'</span><span class="token punctuation">,</span>
        methods<span class="token operator">:</span> <span class="token punctuation">{</span>
            remove<span class="token operator">:</span> <span class="token function">function</span> <span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// this.$emit('事件',参数) 自定义事件分发（远程调用方法）</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>$<span class="token function">emit</span><span class="token punctuation">(</span><span class="token string">'remove'</span><span class="token punctuation">,</span> index<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    let vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        el<span class="token operator">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token comment" spellcheck="true">//标题</span>
            title<span class="token operator">:</span> <span class="token string">"图书馆系列图书"</span><span class="token punctuation">,</span>
            <span class="token comment" spellcheck="true">//列表</span>
            todoItems<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'三国演义'</span><span class="token punctuation">,</span> <span class="token string">'红楼梦'</span><span class="token punctuation">,</span> <span class="token string">'西游记'</span><span class="token punctuation">,</span> <span class="token string">'水浒传'</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        methods<span class="token operator">:</span> <span class="token punctuation">{</span>
            removeItem<span class="token operator">:</span> <span class="token function">function</span> <span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment" spellcheck="true">// 一次删除一个元素</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>todoItems<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
                console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"删除了"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>todoItems<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"OK"</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span>
</code></pre>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Axios</tag>
        <tag>Vue的生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/07/16/hello-world/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><a id="more"></a>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>中缀表达式转后缀表达式</title>
    <url>/2020/08/22/%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<h2 id="中缀表达式转后缀表达式步骤"><a href="#中缀表达式转后缀表达式步骤" class="headerlink" title="中缀表达式转后缀表达式步骤"></a>中缀表达式转后缀表达式步骤</h2><p>1) 初始化两个栈：运算符栈s1和储存中间结果的栈s2； <br><br>2) 从左至右扫描中缀表达式； <br><br>3) 遇到操作数时，将其压s2； <br><br>4) 遇到运算符时，比较其与s1栈顶运算符的优先级：<br><br>&emsp;&emsp;&emsp;&emsp;1.如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；<br><br>&emsp;&emsp;&emsp;&emsp;2.否则，若优先级比栈顶运算符的高，也将运算符压入s1；<br><br>&emsp;&emsp;&emsp;&emsp;3.否则，将s1栈顶的运算符弹出并压入到s2中，再次转到(4.1)与s1中新的栈顶运算符相比较；<br><br>5) 遇到括号时：<br><br>&emsp;&emsp;&emsp;&emsp;(1) 如果是左括号“(”，则直接压入s1<br><br>&emsp;&emsp;&emsp;&emsp;(2) 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃 <br><br>6) 重复步骤2至5，直到表达式的最右边 <br><br>7) 将s1中剩余的运算符依次弹出并压入s2 <br><br>8)  依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式 <br></p>
<h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明:"></a>举例说明:</h2><p>将中缀表达式“1+((2+3)×4)-5”转换为后缀表达式的过程如下</p>
<p>因此结果为<br>“1 2 3 + 4 × + 5 –”</p>
<p><img src="https://img-blog.csdnimg.cn/20200822002413957.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>中缀表达式</tag>
        <tag>后缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/07/16/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>什么都不知道</p>
<a id="more"></a>

<h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><p>也是什么都不知道</p>
<h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><ul>
<li>列表1</li>
<li>列表2</li>
</ul>
<p> <a href="http://www.baidu.com" target="_blank" rel="noopener">百度一下</a></p>
<p> <img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=3722912030,3109009394&fm=26&gp=0.jpg" alt="图片"></p>
<hr>
<p> <em>字体是斜线</em><br> <strong>字体加粗了</strong></p>
<p><code>&lt;html&gt;&lt;/html&gt;</code></p>
<pre><code>&lt;&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre><blockquote>
<p>我的内容是引用的</p>
</blockquote>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis深入——笔记三</title>
    <url>/2020/09/02/%E7%8B%82%E7%A5%9E%E7%AC%94%E8%AE%B0--Redis%E6%B7%B1%E5%85%A5%E2%80%94%E2%80%94%E7%AC%94%E8%AE%B0%E4%B8%89/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<h2 id="十、持久化——RDB"><a href="#十、持久化——RDB" class="headerlink" title="十、持久化——RDB"></a>十、持久化——RDB</h2><blockquote>
<p><strong>RDB：Redis Databases</strong></p>
</blockquote>
<h3 id="emsp-什么是RDB"><a href="#emsp-什么是RDB" class="headerlink" title="&emsp;什么是RDB"></a>&emsp;什么是RDB</h3><p>&emsp;&emsp;<font color=red>在指定时间间隔后，将内存中的数据集快照写入数据库 ；在恢复时候，直接读取快照文件，进行数据的恢复 ；</font></p>
<p><img src="https://img-blog.csdnimg.cn/20200902213922227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>&emsp;&emsp;默认情况下， Redis 将数据库快照保存在名字为 <font color=red>dump.rdb</font>的二进制文件中。文件名可以在配置文件中进行自定义。</p>
<h3 id="emsp-工作原理"><a href="#emsp-工作原理" class="headerlink" title="&emsp;工作原理"></a>&emsp;工作原理</h3><p>&emsp;&emsp;在进行 RDB 的时候，<font color=red>redis</font> 的主线程是不会做<font color=red> io </font>操作的，主线程会 <font color=red>fork</font> 一个子线程来完成该操作；</p>
<ul>
<li>Redis 调用forks。同时拥有父进程和子进程。</li>
<li>子进程将数据集写入到一个临时 RDB 文件中。</li>
<li>当子进程完成对新 RDB 文件的写入时，Redis 用新 RDB 文件替换原来的 RDB 文件，并删除旧的 RDB 文件。</li>
</ul>
<p>&emsp;&emsp;<font color=red><strong>这种工作方式使得 Redis 可以从写时复制（copy-on-write）机制中获益</strong>(因为是使用子进程进行写操作，而父进程依然可以接收来自客户端的请求。)</font></p>
<p><img src="https://img-blog.csdnimg.cn/2020090221495985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h3 id="emsp-触发机制"><a href="#emsp-触发机制" class="headerlink" title="&emsp;触发机制"></a>&emsp;触发机制</h3><p>&emsp;&emsp;<strong>save</strong></p>
<p>&emsp;&emsp;使用 <strong>save</strong> 命令，会立刻对当前内存中的数据进行持久化 ,但是会阻塞，也就是不接受其他操作了；</p>
<blockquote>
<p>由于 <font color=red>save</font> 命令是同步命令，会占用Redis的主进程。若Redis数据非常多时，save命令执行速度会非常慢，阻塞所有客户端的请求。<br><img src="https://img-blog.csdnimg.cn/20200902215153895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
</blockquote>
<p><strong>flushall命令</strong><br><strong>flushall</strong> 命令也会触发持久化 ；</p>
<p><strong>触发持久化规则</strong><br>满足配置条件中的触发条件 ；</p>
<blockquote>
<p>可以通过配置文件对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时， 自动进行数据集保存操作。<br><img src="https://img-blog.csdnimg.cn/20200902215335249.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2020090221540739.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
</blockquote>
<p><strong>bgsave</strong><br>&emsp;&emsp;<font color=red>bgsave</font> 是异步进行，进行持久化的时候，<font color=red>redis</font> 还可以将继续响应客户端请求 ；</p>
<p><img src="https://img-blog.csdnimg.cn/2020090221551855.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>重新启动 redis ，也会触发，记进行加载持久化文件 ；</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody><tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>阻塞？</td>
<td>是</td>
<td>是（阻塞发生在fock()，通常非常快）</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外的内存</td>
<td>不阻塞客户端命令</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端命令</td>
<td>需要fock子进程，消耗内存</td>
</tr>
</tbody></table>
<h3 id="emsp-优缺点"><a href="#emsp-优缺点" class="headerlink" title="&emsp;优缺点"></a>&emsp;优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>适合大规模的数据恢复</li>
<li>对数据的完整性要求不高、</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>需要一定的时间间隔进行操作，如果redis意外宕机了，这个最后一次修改的数据就没有了。</li>
<li>fork进程的时候，会占用一定的内容空间。</li>
</ul>
<h2 id="十一、持久化——AOF"><a href="#十一、持久化——AOF" class="headerlink" title="十一、持久化——AOF"></a>十一、持久化——AOF</h2><h3 id="emsp-什么是AOF"><a href="#emsp-什么是AOF" class="headerlink" title="&emsp;什么是AOF"></a>&emsp;什么是AOF</h3><p>&emsp;&emsp;快照功能（RDB）并不是非常耐久（durable）： 如果 Redis 因为某些原因而造成故障停机， 那么服务器将丢失最近写入、以及未保存到快照中的那些数据。 从 1.1 版本开始， Redis 增加了一种完全耐久的持久化方式： AOF 持久化。</p>
<p>如果要使用AOF，需要修改配置文件：</p>
<p><img src="https://img-blog.csdnimg.cn/20200902220139678.png#pic_center" alt="在这里插入图片描述"><br><font color=red>appendonly no yes</font>则表示启用AOF</p>
<h3 id="emsp-工作原理-1"><a href="#emsp-工作原理-1" class="headerlink" title="&emsp;工作原理"></a>&emsp;工作原理</h3><p>&emsp;&emsp;每当 Redis 执行一个改变数据集的命令时（比如 SET）， 这个命令就会被追加到 AOF 文件的末尾。这样的话， 当 Redis 重新启时， 程序就可以<font color=red><strong>通过重新执行 AOF 文件中的命令来达到重建数据集的目的。</strong></font></p>
<p><strong>创建</strong><br><img src="https://img-blog.csdnimg.cn/20200902220448182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>恢复</strong><br><img src="https://img-blog.csdnimg.cn/20200902220637491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h3 id="emsp-AOF持久化的三种策略"><a href="#emsp-AOF持久化的三种策略" class="headerlink" title="&emsp;AOF持久化的三种策略"></a>&emsp;AOF持久化的三种策略</h3><p><img src="https://img-blog.csdnimg.cn/20200902220737303.png#pic_center" alt=""><br><strong>always</strong></p>
<p>&emsp;&emsp;每次有新命令追加到 AOF 文件时就执行一次同步，安全但是速度慢</p>
<p><img src="https://img-blog.csdnimg.cn/20200902220815786.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>everysec(default)</strong></p>
<p>&emsp;&emsp;这种 fsync 策略可以兼顾速度和安全性，可能丢失一秒的数据。<br><img src="https://img-blog.csdnimg.cn/2020090222085391.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>no</strong></p>
<p>&emsp;&emsp;将数据交给操作系统来处理，由操作系统来决定什么时候同步数据。更快，但是不安全<br><img src="https://img-blog.csdnimg.cn/20200902220939176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>三者对比</strong><br>| 命令 | 优点 | 缺点|<br>|–|–|–|<br>|always  |  不丢失数据| IO开销大，一般SATA磁盘只有几百TPS|<br>| everysec | 每秒进行与fsync，最多丢失1秒数据 | 可能丢失1秒数据|<br>|no  |  不用管| 不可控|</p>
<h3 id="emsp-aof文件修复"><a href="#emsp-aof文件修复" class="headerlink" title="&emsp;aof文件修复"></a>&emsp;aof文件修复</h3><p>&emsp;&emsp;当aof被人为破坏，redis就无法完成启动，可以<font color=red>通过官方提供的 redis-check-aof工具</font>对<font color=red>aof文件</font>进行修复,当然数据可能发生部分丢失。</p>
<pre class=" language-bash"><code class="language-bash">redis-check-aof --fix appendonly.aof</code></pre>
<h3 id="emsp-AOF重写"><a href="#emsp-AOF重写" class="headerlink" title="&emsp;AOF重写"></a>&emsp;AOF重写</h3><p>&emsp;&emsp;因为 AOF 的运作方式是不断地将命令追加到文件的末尾， 所以<font color=red>随着写入命令的不断增加， AOF 文件的体积也会变得越来越大。</font></p>
<p>&emsp;&emsp;举个例子， 如果你对一个计数器调用了 100 次 INCR ， 那么仅仅是为了保存这个计数器的当前值， AOF 文件就需要使用 100 条记录（entry）。然而在实际上， 只使用一条 SET 命令已经足以保存计数器的当前值了， 其余 99 条记录实际上都是多余的。</p>
<p>&emsp;&emsp;为了处理这种情况， Redis 支持一种有趣的特性：<font color=red> 可以在不打断服务客户端的情况下， 对 AOF 文件进行重建（rebuild）。执行 bgrewriteaof 命令， Redis 将生成一个新的 AOF 文件， 这个文件包含重建当前数据集所需的最少命令。</font></p>
<p>&emsp;&emsp;Redis 2.2 需要自己手动执行 bgrewriteaof 命令； <font color=red>Redis 2.4+ 则可以通过配置自动触发 AOF 重写。</font></p>
<p><strong>AOF重写的作用</strong></p>
<ul>
<li>减少磁盘占用量</li>
<li>加速数据恢复</li>
</ul>
<h3 id="emsp-AOF的缺点"><a href="#emsp-AOF的缺点" class="headerlink" title="&emsp;AOF的缺点"></a>&emsp;AOF的缺点</h3><p>&emsp;&emsp;1.对于相同的数据集来说，==AOF 文件的体积通常要大于 RDB 文件的体积。==<br>&emsp;&emsp;2.根据所使用的 fsync 策略，==AOF 的速度可能会慢于 RDB==。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。<br>&emsp;&emsp;3.==数据量较大时，恢复较慢==</p>
<h3 id="emsp-AOF优点"><a href="#emsp-AOF优点" class="headerlink" title="&emsp;AOF优点"></a>&emsp;AOF优点</h3><ul>
<li>一旦出现故障，你最多丢失1秒的数据。</li>
<li>AOF文件是一个只进行追加的日志文件</li>
<li>Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写</li>
<li>AOF 文件的内容非常容易被人读懂， 对文件进行分析（parse）也很轻松</li>
</ul>
<h2 id="十二、RDB-和-AOF-选择"><a href="#十二、RDB-和-AOF-选择" class="headerlink" title="十二、RDB 和 AOF 选择"></a>十二、RDB 和 AOF 选择</h2><h3 id="emsp-RDB-和-AOF-对比"><a href="#emsp-RDB-和-AOF-对比" class="headerlink" title="&emsp;RDB 和 AOF 对比"></a>&emsp;RDB 和 AOF 对比</h3><table>
<thead>
<tr>
<th></th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>丢数据</td>
<td>根据策略决定</td>
</tr>
</tbody></table>
<h3 id="emsp-如何选择使用哪种持久化方式？"><a href="#emsp-如何选择使用哪种持久化方式？" class="headerlink" title="&emsp;如何选择使用哪种持久化方式？"></a>&emsp;如何选择使用哪种持久化方式？</h3><p>&emsp;&emsp;一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。</p>
<p>&emsp;&emsp;如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。</p>
<p>&emsp;&emsp;有很多用户都只使用 AOF 持久化， 但并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快。</p>
<h2 id="十三、Redis发布与订阅"><a href="#十三、Redis发布与订阅" class="headerlink" title="十三、Redis发布与订阅"></a>十三、Redis发布与订阅</h2><p>&emsp;&emsp;Redis 发布订阅(pub/sub)是一种消息通信模式：发送者(pub)发送消息，订阅者(sub)接收消息。</p>
<p><img src="https://img-blog.csdnimg.cn/20200902223507305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>下图展示了频道 channel1 ， 以及订阅这个频道的三个客户端 —— client2 、 client5 和 client1 之间的关系：<br><img src="https://img-blog.csdnimg.cn/2020090222352751.png#pic_center" alt=""><br>当有新消息通过 PUBLISH 命令发送给频道 channel1 时， 这个消息就会被发送给订阅它的三个客户端：<br><img src="https://img-blog.csdnimg.cn/20200902223543741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h3 id="emsp-命令"><a href="#emsp-命令" class="headerlink" title="&emsp;命令"></a>&emsp;命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><font color=red> PSUBSCRIBE pattern [pattern..]</font></td>
<td>订阅一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td><font color=red>PUNSUBSCRIBE pattern [pattern..] </font></td>
<td>退订一个或多个符合给定模式的频道。</td>
</tr>
<tr>
<td><font color=red> PUBSUB subcommand [argument[argument]]</font></td>
<td>查看订阅与发布系统状态。</td>
</tr>
<tr>
<td><font color=red>PUBLISH channel message </font></td>
<td>向指定频道发布消息</td>
</tr>
<tr>
<td><font color=red>SUBSCRIBE channel [channel..] </font></td>
<td>订阅给定的一个或多个频道。</td>
</tr>
<tr>
<td><font color=red>SUBSCRIBE channel [channel..] </font></td>
<td>退订一个或多个频道</td>
</tr>
</tbody></table>
<pre class=" language-java"><code class="language-java"><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>订阅端<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
<span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> SUBSCRIBE sakura # 订阅sakura频道
Reading messages<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">(</span>press Ctrl<span class="token operator">-</span>C to quit<span class="token punctuation">)</span> # 等待接收消息
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"subscribe"</span> # 订阅成功的消息
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"sakura"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"message"</span> # 接收到来自sakura频道的消息 <span class="token string">"hello world"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"sakura"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"hello world"</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"message"</span> # 接收到来自sakura频道的消息 <span class="token string">"hello i am sakura"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"sakura"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"hello i am sakura"</span>

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>消息发布端<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
<span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> PUBLISH sakura <span class="token string">"hello world"</span> # 发布消息到sakura频道
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> PUBLISH sakura <span class="token string">"hello i am sakura"</span> # 发布消息
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>查看活跃的频道<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
<span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> PUBSUB channels
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"sakura"</span>
</code></pre>
<h3 id="emsp-原理"><a href="#emsp-原理" class="headerlink" title="&emsp;原理"></a>&emsp;原理</h3><p>&emsp;&emsp;每个 Redis 服务器进程都维持着一个表示服务器状态的 redis.h/redisServer 结构， 结构的 pubsub_channels 属性是一个字典， 这个==字典就用于保存订阅频道的信息==，其中，==字典的键为正在被订阅的频道， 而字典的值则是一个链表==， 链表中保存了==所有订阅这个频道的客户端。==</p>
<p><img src="https://img-blog.csdnimg.cn/20200902224054259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>客户端订阅，就被链接到对应频道的链表的尾部，退订则就是将客户端节点从链表中移除。</p>
<p><strong>缺点</strong></p>
<p>&emsp;&emsp;1，如果一个客户端订阅了频道，但自己读取消息的速度却不够快的话，那么不断积压的消息会使redis输出缓冲区的体积变得越来越大，这可能使得redis本身的速度变慢，甚至直接崩溃。<br>&emsp;&emsp;2，这和数据传输可靠性有关，如果在订阅方断线，那么他将会丢失所有在短线期间发布者发布的消息。</p>
<p><strong>应用</strong><br>&emsp;&emsp;消息订阅：公众号订阅，微博关注等等（起始更多是使用消息队列来进行实现）<br>&emsp;&emsp;多人在线聊天室。</p>
<h2 id="十四、主从复制"><a href="#十四、主从复制" class="headerlink" title="十四、主从复制"></a>十四、主从复制</h2><h3 id="emsp-概念"><a href="#emsp-概念" class="headerlink" title="&emsp;概念"></a>&emsp;概念</h3><p>&emsp;&emsp;主从复制，是指将一台Redis服务器的数据，复制到其他的Redis服务器。前者称为主节点（Master/Leader）,后者称为从节点（Slave/Follower），==<strong>数据的复制是单向的！只能由主节点复制到从节点</strong>==（主节点以写为主、从节点以读为主）。</p>
<p>&emsp;&emsp;默认情况下，每台Redis服务器都是主节点，一个主节点可以有0个或者多个从节点，但每个从节点只能由一个主节点。</p>
<h3 id="emsp-作用"><a href="#emsp-作用" class="headerlink" title="&emsp;作用"></a>&emsp;作用</h3><p>&emsp;&emsp;<font color=red>1.数据冗余</font>：主从复制实现了数据的热备份，是持久化之外的一种数据冗余的方式。<br>&emsp;&emsp;<font color=red>2.故障恢复</font>：当主节点故障时，从节点可以暂时替代主节点提供服务，是一种服务冗余的方式<br>&emsp;&emsp;<font color=red>3.负载均衡</font>：在主从复制的基础上，配合读写分离，由主节点进行写操作，从节点进行读操作，分担服务器的负载；尤其是在多读少写的场景下，通过多个从节点分担负载，提高并发量。<br>&emsp;&emsp;<font color=red>4.高可用基石</font>：主从复制还是哨兵和集群能够实施的基础。</p>
<h3 id="emsp-为什么使用集群"><a href="#emsp-为什么使用集群" class="headerlink" title="&emsp;为什么使用集群"></a>&emsp;为什么使用集群</h3><ul>
<li>单台服务器难以负载大量的请求</li>
<li>单台服务器故障率高，系统崩坏概率大</li>
<li>单台服务器内存容量有限。</li>
</ul>
<h3 id="emsp-环境配置"><a href="#emsp-环境配置" class="headerlink" title="&emsp;环境配置"></a>&emsp;环境配置</h3><p>&emsp;&emsp;我们在讲解配置文件的时候，注意到有一个replication模块 (见Redis.conf中第8条)</p>
<p>&emsp;&emsp;查看当前库的信息：<font color=red> info replication</font></p>
<pre class=" language-java"><code class="language-java"><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> info replication
# Replication
role<span class="token operator">:</span>master # 角色
connected_slaves<span class="token operator">:</span><span class="token number">0</span> # 从机数量
master_replid<span class="token operator">:</span>3b54deef5b7b7b7f7dd8acefa23be48879b4fcff
master_replid2<span class="token operator">:</span><span class="token number">0000000000000000000000000000000000000000</span>
master_repl_offset<span class="token operator">:</span><span class="token number">0</span>
second_repl_offset<span class="token operator">:</span><span class="token operator">-</span><span class="token number">1</span>
repl_backlog_active<span class="token operator">:</span><span class="token number">0</span>
repl_backlog_size<span class="token operator">:</span><span class="token number">1048576</span>
repl_backlog_first_byte_offset<span class="token operator">:</span><span class="token number">0</span>
repl_backlog_histlen<span class="token operator">:</span><span class="token number">0</span>
</code></pre>
<p>既然需要启动多个服务，就需要多个配置文件。每个配置文件对应修改以下信息：</p>
<ul>
<li>端口号</li>
<li>pid文件名</li>
<li>日志文件名</li>
<li>rdb文件名</li>
</ul>
<p>启动单机多服务集群：</p>
<p><img src="https://img-blog.csdnimg.cn/20200902225006902.png#pic_center" alt=""></p>
<h3 id="emsp-一主二从配置"><a href="#emsp-一主二从配置" class="headerlink" title="&emsp;一主二从配置"></a>&emsp;一主二从配置</h3><p>此时每个redis都是主节点，此时我们只需配置我们想要的从机即可。</p>
<p><img src="https://img-blog.csdnimg.cn/2020090222504562.png#pic_center" alt=""><br>使用<font color=red> SLAVEOF host port</font>就可以为从机配置主机了。<br><img src="https://img-blog.csdnimg.cn/20200902225116868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>然后主机上也能看到从机的状态：<br><img src="https://img-blog.csdnimg.cn/20200902225134119.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>我们这里是使用命令搭建，是暂时的，<strong>真实开发中应该在从机的配置文件中进行配置。</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200902225202382.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h3 id="emsp-使用规则"><a href="#emsp-使用规则" class="headerlink" title="&emsp;使用规则"></a>&emsp;使用规则</h3><p>1.从机只能读，不能写，主机可读可写但是多用于写。</p>
<pre class=" language-java"><code class="language-java"><span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6381</span><span class="token operator">></span> set name sakura # 从机<span class="token number">6381</span>写入失败
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> READONLY You can't write against a read only replica<span class="token punctuation">.</span>

<span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6380</span><span class="token operator">></span> set name sakura # 从机<span class="token number">6380</span>写入失败
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> READONLY You can't write against a read only replica<span class="token punctuation">.</span>

<span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> set name sakura
OK
<span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">></span> get name
<span class="token string">"sakura"</span>
</code></pre>
<p>2.当主机断电宕机后，默认情况下从机的角色不会发生变化 ，集群中只是失去了写操作，当主机恢复以后，又会连接上从机恢复原状。</p>
<p>3.当从机断电宕机后，若不是使用配置文件配置的从机，再次启动后作为主机是无法获取之前主机的数据的，若此时重新配置称为从机，又可以获取到主机的所有数据。这里就要提到一个同步原理。</p>
<p>4.第二条中提到，默认情况下，主机故障后，不会出现新的主机，有两种方式可以产生新的主机：</p>
<ul>
<li>从机手动执行命令<font color=red>slaveof no one</font>,这样执行以后从机会独立出来成为一个主机</li>
<li>使用哨兵模式（自动选举）</li>
</ul>
<h3 id="emsp-同步复制原理"><a href="#emsp-同步复制原理" class="headerlink" title="&emsp;同步复制原理"></a>&emsp;同步复制原理</h3><p><strong>全量同步</strong></p>
<p>==Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。==</p>
<p>具体步骤如下：</p>
<ul>
<li>从服务器连接主服务器，发送SYNC命令；</li>
<li>主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文 件并使用缓冲区记录此后执行的所有写命令；</li>
<li>主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；</li>
<li>从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；</li>
<li>主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；</li>
<li>从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；<br><img src="https://img-blog.csdnimg.cn/20200902225651744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></li>
</ul>
<p><strong>增量同步</strong></p>
<p>==Redis增量复制是指Slave初始化后开始正常工作时，主服务器发生的写操作同步到从服务器的过程。==</p>
<p>增量复制的过程主要：</p>
<ul>
<li>主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。</li>
</ul>
<h2 id="十五、哨兵模式"><a href="#十五、哨兵模式" class="headerlink" title="十五、哨兵模式"></a>十五、哨兵模式</h2><blockquote>
<p>更多信息参考博客：<a href="https://www.jianshu.com/p/06ab9daf921d" target="_blank" rel="noopener">https://www.jianshu.com/p/06ab9daf921d</a></p>
</blockquote>
<p><strong>主从切换技术的方法是：当主服务器宕机后，需要手动把一台从服务器切换为主服务器，这就需要人工干预，费事费力，还会造成一段时间内服务不可用。这不是一种推荐的方式，更多时候，我们优先考虑哨兵模式。</strong></p>
<p>单机单个哨兵<br><img src="https://img-blog.csdnimg.cn/20200902225906568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>哨兵的作用：</p>
<ul>
<li><p>通过发送命令，让Redis服务器返回监控其运行状态，包括主服务器和从服务器。</p>
</li>
<li><p>当哨兵监测到master宕机，会自动将slave切换成master，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机。</p>
</li>
</ul>
<p>多哨兵模式<br><img src="https://img-blog.csdnimg.cn/20200902225933750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>哨兵的核心配置</p>
<pre class=" language-bash"><code class="language-bash">sentinel monitor mymaster 127.0.0.1 6379 1</code></pre>
<p>数字1表示 ：当一个哨兵主观认为主机断开，就可以客观认为主机故障，然后开始选举新的主机。</p>
<p>完整的哨兵模式配置文件 sentinel.conf</p>
<pre class=" language-java"><code class="language-java"># Example sentinel<span class="token punctuation">.</span>conf

# 哨兵sentinel实例运行的端口 默认<span class="token number">26379</span>
port <span class="token number">26379</span>

# 哨兵sentinel的工作目录
dir <span class="token operator">/</span>tmp

# 哨兵sentinel监控的redis主节点的 ip port 
# master<span class="token operator">-</span>name  可以自己命名的主节点名字 只能由字母A<span class="token operator">-</span>z、数字<span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span> 、这三个字符<span class="token string">".-_"</span>组成。
# quorum 当这些quorum个数sentinel哨兵认为master主节点失联 那么这时 客观上认为主节点失联了
# sentinel monitor <span class="token operator">&lt;</span>master<span class="token operator">-</span>name<span class="token operator">></span> <span class="token operator">&lt;</span>ip<span class="token operator">></span> <span class="token operator">&lt;</span>redis<span class="token operator">-</span>port<span class="token operator">></span> <span class="token operator">&lt;</span>quorum<span class="token operator">></span>
sentinel monitor mymaster <span class="token number">127.0</span><span class="token punctuation">.</span><span class="token number">0.1</span> <span class="token number">6379</span> <span class="token number">1</span>

# 当在Redis实例中开启了requirepass foobared 授权密码 这样所有连接Redis实例的客户端都要提供密码
# 设置哨兵sentinel 连接主从的密码 注意必须为主从设置一样的验证密码
# sentinel auth<span class="token operator">-</span>pass <span class="token operator">&lt;</span>master<span class="token operator">-</span>name<span class="token operator">></span> <span class="token operator">&lt;</span>password<span class="token operator">></span>
sentinel auth<span class="token operator">-</span>pass mymaster MySUPER<span class="token operator">--</span>secret<span class="token operator">-</span>0123passw0rd


# 指定多少毫秒之后 主节点没有应答哨兵sentinel 此时 哨兵主观上认为主节点下线 默认<span class="token number">30</span>秒
# sentinel down<span class="token operator">-</span>after<span class="token operator">-</span>milliseconds <span class="token operator">&lt;</span>master<span class="token operator">-</span>name<span class="token operator">></span> <span class="token operator">&lt;</span>milliseconds<span class="token operator">></span>
sentinel down<span class="token operator">-</span>after<span class="token operator">-</span>milliseconds mymaster <span class="token number">30000</span>

# 这个配置项指定了在发生failover主备切换时最多可以有多少个slave同时对新的master进行 同步，
这个数字越小，完成failover所需的时间就越长，
但是如果这个数字越大，就意味着越 多的slave因为replication而不可用。
可以通过将这个值设为 <span class="token number">1</span> 来保证每次只有一个slave 处于不能处理命令请求的状态。
# sentinel parallel<span class="token operator">-</span>syncs <span class="token operator">&lt;</span>master<span class="token operator">-</span>name<span class="token operator">></span> <span class="token operator">&lt;</span>numslaves<span class="token operator">></span>
sentinel parallel<span class="token operator">-</span>syncs mymaster <span class="token number">1</span>



# 故障转移的超时时间 failover<span class="token operator">-</span>timeout 可以用在以下这些方面： 
#<span class="token number">1</span><span class="token punctuation">.</span> 同一个sentinel对同一个master两次failover之间的间隔时间。
#<span class="token number">2</span><span class="token punctuation">.</span> 当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。
#<span class="token number">3</span><span class="token punctuation">.</span>当想要取消一个正在进行的failover所需要的时间。  
#<span class="token number">4</span><span class="token punctuation">.</span>当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel<span class="token operator">-</span>syncs所配置的规则来了
# 默认三分钟
# sentinel failover<span class="token operator">-</span>timeout <span class="token operator">&lt;</span>master<span class="token operator">-</span>name<span class="token operator">></span> <span class="token operator">&lt;</span>milliseconds<span class="token operator">></span>
sentinel failover<span class="token operator">-</span>timeout mymaster <span class="token number">180000</span>

# SCRIPTS EXECUTION

#配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。
#对于脚本的运行结果有以下规则：
#若脚本执行后返回<span class="token number">1</span>，那么该脚本稍后将会被再次执行，重复次数目前默认为<span class="token number">10</span>
#若脚本执行后返回<span class="token number">2</span>，或者比<span class="token number">2</span>更高的一个返回值，脚本将不会重复执行。
#如果脚本在执行过程中由于收到系统中断信号被终止了，则同返回值为<span class="token number">1</span>时的行为相同。
#一个脚本的最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行。

#通知型脚本<span class="token operator">:</span>当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，
#这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将传给脚本两个参数，
#一个是事件的类型，
#一个是事件的描述。
#如果sentinel<span class="token punctuation">.</span>conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。
#通知脚本
# sentinel notification<span class="token operator">-</span>script <span class="token operator">&lt;</span>master<span class="token operator">-</span>name<span class="token operator">></span> <span class="token operator">&lt;</span>script<span class="token operator">-</span>path<span class="token operator">></span>
  sentinel notification<span class="token operator">-</span>script mymaster <span class="token operator">/</span>var<span class="token operator">/</span>redis<span class="token operator">/</span>notify<span class="token punctuation">.</span>sh

# 客户端重新配置主节点参数脚本
# 当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。
# 以下参数将会在调用脚本时传给脚本<span class="token operator">:</span>
# <span class="token operator">&lt;</span>master<span class="token operator">-</span>name<span class="token operator">></span> <span class="token operator">&lt;</span>role<span class="token operator">></span> <span class="token operator">&lt;</span>state<span class="token operator">></span> <span class="token operator">&lt;</span>from<span class="token operator">-</span>ip<span class="token operator">></span> <span class="token operator">&lt;</span>from<span class="token operator">-</span>port<span class="token operator">></span> <span class="token operator">&lt;</span>to<span class="token operator">-</span>ip<span class="token operator">></span> <span class="token operator">&lt;</span>to<span class="token operator">-</span>port<span class="token operator">></span>
# 目前<span class="token operator">&lt;</span>state<span class="token operator">></span>总是“failover”<span class="token punctuation">,</span>
# <span class="token operator">&lt;</span>role<span class="token operator">></span>是“leader”或者“observer”中的一个。 
# 参数 from<span class="token operator">-</span>ip<span class="token punctuation">,</span> from<span class="token operator">-</span>port<span class="token punctuation">,</span> to<span class="token operator">-</span>ip<span class="token punctuation">,</span> to<span class="token operator">-</span>port是用来和旧的master和新的<span class="token function">master</span><span class="token punctuation">(</span>即旧的slave<span class="token punctuation">)</span>通信的
# 这个脚本应该是通用的，能被多次调用，不是针对性的。
# sentinel client<span class="token operator">-</span>reconfig<span class="token operator">-</span>script <span class="token operator">&lt;</span>master<span class="token operator">-</span>name<span class="token operator">></span> <span class="token operator">&lt;</span>script<span class="token operator">-</span>path<span class="token operator">></span>
sentinel client<span class="token operator">-</span>reconfig<span class="token operator">-</span>script mymaster <span class="token operator">/</span>var<span class="token operator">/</span>redis<span class="token operator">/</span>reconfig<span class="token punctuation">.</span>sh
</code></pre>
<p><font color=red>redis-sentinel xxx/sentinel.conf</font></p>
<p>成功启动哨兵模式</p>
<p><img src="https://img-blog.csdnimg.cn/202009022301005.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>此时哨兵监视着我们的主机6379，当我们断开主机后：<br><img src="https://img-blog.csdnimg.cn/20200902230117886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h2 id="十六、缓存穿透与雪崩"><a href="#十六、缓存穿透与雪崩" class="headerlink" title="十六、缓存穿透与雪崩"></a>十六、缓存穿透与雪崩</h2><h3 id="emsp-缓存穿透"><a href="#emsp-缓存穿透" class="headerlink" title="&emsp;缓存穿透"></a>&emsp;缓存穿透</h3><p><strong>概念</strong></p>
<p>&emsp;&emsp;在默认情况下，用户请求数据时，会先在缓存(Redis)中查找，若没找到即缓存未命中，再在数据库中进行查找，数量少可能问题不大，可是一旦大量的请求数据（例如秒杀场景）缓存都没有命中的话，就会全部转移到数据库上，造成数据库极大的压力，就有可能导致数据库崩溃。网络安全中也有人恶意使用这种手段进行攻击被称为洪水攻击。</p>
<p><strong>解决方案</strong></p>
<p>1.布隆过滤器</p>
<p>&emsp;&emsp;对所有可能查询的参数以Hash的形式存储，以便快速确定是否存在这个值，在控制层先进行拦截校验，校验不通过直接打回，减轻了存储系统的压力。<br><img src="https://img-blog.csdnimg.cn/20200902230247979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>2.缓存空对象</p>
<p>&emsp;&emsp;一次请求若在缓存和数据库中都没找到，就在缓存中方一个空对象用于处理后续这个请求。<br><img src="https://img-blog.csdnimg.cn/2020090223035087.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>这样做有一个缺陷：存储空对象也需要空间，大量的空对象会耗费一定的空间，存储效率并不高。解决这个缺陷的方式就是<font color=red>设置较短过期时间</font></p>
<p>即使对空值设置了过期时间，还是会存在缓存层和存储层的数据会有一段时间窗口的不一致，这对于需要保持一致性的业务会有影响。</p>
<h3 id="emsp-缓存击穿"><a href="#emsp-缓存击穿" class="headerlink" title="&emsp;缓存击穿"></a>&emsp;缓存击穿</h3><p><strong>概念</strong></p>
<p>&emsp;&emsp;相较于缓存穿透，缓存击穿的目的性更强，一个存在的key，在缓存过期的一刻，同时有大量的请求，这些请求都会击穿到DB，造成瞬时DB请求量大、压力骤增。这就是缓存被击穿，只是针对其中某个key的缓存不可用而导致击穿，但是其他的key依然可以使用缓存响应。</p>
<p>&emsp;&emsp;比如热搜排行上，一个热点新闻被同时大量访问就可能导致缓存击穿。</p>
<p><strong>解决方案</strong></p>
<p>1.设置热点数据永不过期</p>
<p>&emsp;&emsp;这样就不会出现热点数据过期的情况，但是当Redis内存空间满的时候也会清理部分数据，而且此种方案会占用空间，一旦热点数据多了起来，就会占用部分空间。</p>
<p>2.加互斥锁(分布式锁)</p>
<p>&emsp;&emsp;在访问key之前，采用SETNX（set if not exists）来设置另一个短期key来锁住当前key的访问，访问结束再删除该短期key。保证同时刻只有一个线程访问。这样对锁的要求就十分高。</p>
<h3 id="emsp-缓存雪崩"><a href="#emsp-缓存雪崩" class="headerlink" title="&emsp;缓存雪崩"></a>&emsp;缓存雪崩</h3><p><strong>概念</strong><br>&emsp;&emsp;大量的key设置了相同的过期时间，导致在缓存在同一时刻全部失效，造成瞬时DB请求量大、压力骤增，引起雪崩。</p>
<p><img src="https://img-blog.csdnimg.cn/20200902230635843.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><strong>解决方案</strong></p>
<ul>
<li>redis高可用</li>
</ul>
<p>&emsp;&emsp;这个思想的含义是，既然redis有可能挂掉，那我多增设几台redis，这样一台挂掉之后其他的还可以继续工作，其实就是<font color=red> 搭建的集群</font></p>
<ul>
<li>限流降级</li>
</ul>
<p>&emsp;&emsp;这个解决方案的思想是，在缓存失效后，通过<font color=red> 加锁或者队列来控制读数据库写缓存的线程数量</font>。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。</p>
<ul>
<li>数据预热</li>
</ul>
<p>&emsp;&emsp;数据加热的含义就是在正式部署之前，我先<font color=red> 把可能的数据先预先访问一遍，这样部分可能大量访问的数据就会加载到缓存中</font>。在即将发生大并发访问前手动触发加载缓存不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>RDB</tag>
        <tag>AOF</tag>
        <tag>主从复制</tag>
        <tag>哨兵模式</tag>
        <tag>缓存穿透与雪崩</tag>
      </tags>
  </entry>
  <entry>
    <title>第一个Vue程序</title>
    <url>/2020/08/24/%E7%AC%AC%E4%B8%80%E4%B8%AAVue%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>&emsp;&emsp; Vue (读音/vju/, 类似于view)是一套用于构建用户界面的渐进式框架，发布于2014年2月。与其它大型框架不同的是，Vue被设计为可以自底向上逐层应用。Vue的核心库只关注视图层，不仅易于上手，还便于与第三方库(如: vue-router, vue-resource, vuex)或既有项目整合。</p>
<h2 id="MVVM模式的实现者"><a href="#MVVM模式的实现者" class="headerlink" title="MVVM模式的实现者"></a>MVVM模式的实现者</h2><p>●<font color=red><strong>Model</strong></font>:模型层，在这里表示JavaScript对象<br>●<font color=red><strong>View</strong></font>:视图层,在这里表示DOM (HTML操作的元素)<br>●<font color=red><strong>ViewModel</strong></font>:连接视图和数据的中间件，Vue.js就是MVVM中的ViewModel层的实现者<br><strong>&emsp;&emsp;<font color=green>在MVVM架构中，是不允许数据和视图直接通信的，只能通过ViewModel来通信，而ViewModel就是定义了一个Observer观察者</font></strong><br>●<font color=red><strong>ViewModel</strong></font>能够观察到数据的变化，并对视图对应的内容进行更新<br>●<font color=red><strong>ViewModel</strong></font>能够监听到视图的变化，并能够通知数据发生改变</p>
<p>&emsp;&emsp;<font color=blue><strong><em>至此，我们就明白了，Vue.js 就是一个MVVM的实现者，他的核心就是实现了DOM监听与数据绑定</em></strong></font></p>
<h2 id="为什么要使用Vue-js"><a href="#为什么要使用Vue-js" class="headerlink" title="为什么要使用Vue.js"></a>为什么要使用Vue.js</h2><p>●<font color=red>轻量级</font>，体积小是一个重要指标。Vue.js 压缩后有只有20多kb (Angular 压缩后56kb+ ,<br>React压缩后44kb+ )<br>●<font color=red>移动优先</font>。更适合移动端，比如移动端的Touch事件<br>●<font color=red>易上手</font>，学习曲线平稳,文档齐全<br>●<font color=red>吸取了Angular (模块化)和React (虚拟DOM)的长处</font>，并拥有自己独特的功能，如:计算属性<br>●<font color=red>开源</font>，社区活跃度高</p>
<p><strong>代码 demo1.html 初入门之绑定数据</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span>
<span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>head<span class="token operator">></span>
    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>title<span class="token operator">></span>Title<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token number">1</span><span class="token punctuation">.</span>导入vue<span class="token punctuation">.</span>js<span class="token operator">--</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>
<span class="token operator">&lt;</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span>
    <span class="token punctuation">{</span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span>script<span class="token operator">></span>
     let vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        el<span class="token operator">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token punctuation">{</span>
            message<span class="token operator">:</span> <span class="token string">"hello,vue"</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span>

</code></pre>
<h2 id="什么是MVVM"><a href="#什么是MVVM" class="headerlink" title="什么是MVVM?"></a>什么是MVVM?</h2><p>&emsp;&emsp; MVVM (Model-View-ViewModel) 是一种软件架构设计模式，由微软WPF (用于替代WinForm，以前就是用这个技术开发桌面应用程序的)和Silverlight (类似于Java Applet,简单点说就是在浏览器上运行的WPF)的架构师Ken Cooper和Ted Peters 开发，是一种简化用户界面的<font color=red><strong><em>事件驱动编程方式</em></strong></font>。由John Gossman (同样也是WPF和Silverlight的架构师)于2005年在他的博客上发表。<br>&emsp;&emsp; MVVM源自于经典的MVC (ModI-View-Controller) 模式。<strong><font color=red>MVVM的核心是ViewModel层</font>，<font color=red>负责转换Model中的数据对象来让数据变得更容易管理和使用</font>，</strong></p>
<p><strong>其作用如下:</strong><br>●<font color=blue><em>该层向上与视图层进行双向数据绑定<br>●向下与Model层通过接口请求进行数据交互</em></font></p>
<p><img src="https://img-blog.csdnimg.cn/20200824012825185.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt="MVVM图解"></p>
<h2 id="为什么要使用MVVM"><a href="#为什么要使用MVVM" class="headerlink" title="为什么要使用MVVM"></a>为什么要使用MVVM</h2><p>&emsp;&emsp; MVVM模式和MVC模式一样，主要目的是分离视图(View)和模型(Model),有几大好处<br>●<font color=red>低耦合</font>:视图(View)可以独立于Model变化和修改,一个ViewModel可以绑定到不同的<br>View上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。<br>●<font color=red>可复用</font>:你可以把一些视图逻辑放在一个ViewModel里面，让很多View重用这段视图逻辑。<br>●<font color=red>独立开发</font>:开发人员可以专注于业务逻辑和数据的开发(ViewModel),设计人员可以专注于页面设计。<br>●<font color=red>可测试</font>:界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。</p>
<p><strong>代码 demo2.html if else 语法</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span>
<span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>head<span class="token operator">></span>
    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>title<span class="token operator">></span>Title<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token number">1</span><span class="token punctuation">.</span>导入vue<span class="token punctuation">.</span>js<span class="token operator">--</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>
<span class="token operator">&lt;</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>h1 v<span class="token operator">-</span><span class="token keyword">if</span><span class="token operator">=</span><span class="token string">"ok"</span><span class="token operator">></span>Yes<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>
    <span class="token operator">&lt;</span>h1 v<span class="token operator">-</span><span class="token keyword">else</span><span class="token operator">></span>No<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span>script<span class="token operator">></span>
    let vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        el<span class="token operator">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token punctuation">{</span>
            ok<span class="token operator">:</span> <span class="token boolean">true</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span>
</code></pre>
<p><strong>代码 demo03.html for循环获取数据</strong></p>
<pre class=" language-java"><code class="language-java">
<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span>
<span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>head<span class="token operator">></span>
    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>title<span class="token operator">></span>Title<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token number">1</span><span class="token punctuation">.</span>导入vue<span class="token punctuation">.</span>js<span class="token operator">--</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>
<span class="token operator">&lt;</span>body<span class="token operator">></span>

<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>li v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"text in allTexts"</span><span class="token operator">></span>
        <span class="token punctuation">{</span><span class="token punctuation">{</span>text<span class="token punctuation">.</span>message<span class="token punctuation">}</span><span class="token punctuation">}</span>
    <span class="token operator">&lt;</span><span class="token operator">/</span>li<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span>script<span class="token operator">></span>
    let vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        el<span class="token operator">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token punctuation">{</span>
            allTexts<span class="token operator">:</span> <span class="token punctuation">[</span>
                <span class="token punctuation">{</span>message<span class="token operator">:</span> <span class="token string">"1"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token punctuation">{</span>message<span class="token operator">:</span> <span class="token string">"2"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token punctuation">{</span>message<span class="token operator">:</span> <span class="token string">"3"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
            <span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span></code></pre>
<p><strong>代码demo04 事件绑定</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span>
<span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>head<span class="token operator">></span>
    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>title<span class="token operator">></span>Title<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token number">1</span><span class="token punctuation">.</span>导入vue<span class="token punctuation">.</span>js<span class="token operator">--</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>
<span class="token operator">&lt;</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>button v<span class="token operator">-</span>on<span class="token operator">:</span>click<span class="token operator">=</span><span class="token string">"sayHi()"</span><span class="token operator">></span>点我<span class="token operator">&lt;</span><span class="token operator">/</span>button<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span>script<span class="token operator">></span>
    let vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        el<span class="token operator">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token punctuation">{</span>
            message<span class="token operator">:</span> <span class="token string">"cqh"</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        methods<span class="token operator">:</span> <span class="token punctuation">{</span>
            sayHi<span class="token operator">:</span> <span class="token function">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span>
</code></pre>
<h2 id="什么是双向数据绑定"><a href="#什么是双向数据绑定" class="headerlink" title="什么是双向数据绑定"></a>什么是双向数据绑定</h2><p> &emsp; <font color=red><strong>Vue.js是一个MVVM框架，即数据双向绑定,即当数据发生变化的时候,视图也就发生变化，当视图发生变化的时候，数据也会跟着同步变化。这也算是Vue.js的精髓之处了。</strong></font><br> 值得注意的是，我们所说的数据双向绑定，一定是对于UI控件来说的，非UI控件不会涉及到数据双向绑定。单向数据绑定是使用状态管理工具的前提。如果我们使用vuex，那么数据流也是单项的，这时就会和双向数据绑定有冲突。</p>
<h2 id="为什么要实现数据的双向绑定"><a href="#为什么要实现数据的双向绑定" class="headerlink" title="为什么要实现数据的双向绑定"></a>为什么要实现数据的双向绑定</h2><p> &emsp;&emsp; 在Vue.js 中，如果使用vuex ，实际上数据还是单向的，之所以说是数据双向绑定，这是用的UI控件来说，对于我们处理表单，Vue.js的双向数据绑定用起来就特别舒服了。即两者并不互斥，在全局性数据流使用单项,方便跟踪;局部性数据流使用双向，简单易操作。</p>
<h2 id="在表单中使用双向数据绑定"><a href="#在表单中使用双向数据绑定" class="headerlink" title="在表单中使用双向数据绑定"></a>在表单中使用双向数据绑定</h2><p> &emsp;&emsp; 你可以用v-model 指令在表单 、 及 元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。尽管有些神奇，但v-model本质上不过是语法糖。它负责监听户的输入事件以更新数据，并对一些极端场景进行一些特殊处理。<br>代码 demo05 数据双向绑定示例 实现之后当输入框输入相应文字 在后面提示框会输入相同文字</p>
<p><br>``</p>
<p><font color=red><strong>代码 demo05 数据双向绑定示例 实现之后当输入框输入相应文字 在后面提示框会输入相同文字</strong></font></p>
<pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span>
<span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>head<span class="token operator">></span>
    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>title<span class="token operator">></span>Title<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token number">1</span><span class="token punctuation">.</span>导入vue<span class="token punctuation">.</span>js<span class="token operator">--</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>
<span class="token operator">&lt;</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span>
    数据双向绑定示例：<span class="token operator">&lt;</span>input type<span class="token operator">=</span><span class="token string">"text"</span> v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">"message"</span><span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">{</span>message<span class="token punctuation">}</span><span class="token punctuation">}</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span>script<span class="token operator">></span>
    let vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        el<span class="token operator">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token punctuation">{</span>
            message<span class="token operator">:</span> <span class="token string">""</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span>
</code></pre>
<h2 id="什么是组件"><a href="#什么是组件" class="headerlink" title="什么是组件"></a>什么是组件</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;组件是可复用的Vue实例，说白了就是一组可以重复使用的模板，跟JSTL的自定义标签、Thymeleaf的th:fragment 等框架有着异曲同工之妙。通常一个应用会以一棵嵌套的组件树的形式来组织:<br>&nbsp;&nbsp;&nbsp; 注意:在实际开发中，我们并不会用以下方式开发组件，而是采用vue-cli创建.vue模板文件的方式开发，以下方法只是为了让大家理解什么是组件。<br><br><font color=red>Vue.component()方法注册组件</font></p>
<p><strong>代码 组件练习 demo06</strong></p>
<pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE html<span class="token operator">></span>
<span class="token operator">&lt;</span>html lang<span class="token operator">=</span><span class="token string">"en"</span><span class="token operator">></span>
<span class="token operator">&lt;</span>head<span class="token operator">></span>
    <span class="token operator">&lt;</span>meta charset<span class="token operator">=</span><span class="token string">"UTF-8"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>title<span class="token operator">></span>Title<span class="token operator">&lt;</span><span class="token operator">/</span>title<span class="token operator">></span>
    <span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token number">1</span><span class="token punctuation">.</span>导入vue<span class="token punctuation">.</span>js<span class="token operator">--</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.min.js"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>head<span class="token operator">></span>
<span class="token operator">&lt;</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span>div id<span class="token operator">=</span><span class="token string">"app"</span><span class="token operator">></span>
    <span class="token operator">&lt;</span>cqh v<span class="token operator">-</span><span class="token keyword">for</span><span class="token operator">=</span><span class="token string">"item in items"</span> v<span class="token operator">-</span>bind<span class="token operator">:</span>testComponent<span class="token operator">=</span><span class="token string">"item"</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>cqh<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">></span>
<span class="token operator">&lt;</span>script<span class="token operator">></span>
    <span class="token comment" spellcheck="true">/*定义一个vue组件*/</span>
    Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">"cqh"</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        props<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'testComponent'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
        template<span class="token operator">:</span> <span class="token string">'&lt;li>{{testComponent}}&lt;/li>'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    let vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        el<span class="token operator">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>
        data<span class="token operator">:</span> <span class="token punctuation">{</span>
            items<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"Java"</span><span class="token punctuation">,</span> <span class="token string">"Linux"</span><span class="token punctuation">,</span> <span class="token string">"前端"</span><span class="token punctuation">]</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>body<span class="token operator">></span>
<span class="token operator">&lt;</span><span class="token operator">/</span>html<span class="token operator">></span>

</code></pre>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>解决CentOS7虚拟机无法上网并设置CentOS7虚拟机使用静态IP上网</title>
    <url>/2020/08/27/%E8%A7%A3%E5%86%B3CentOS7%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%97%A0%E6%B3%95%E4%B8%8A%E7%BD%91%E5%B9%B6%E8%AE%BE%E7%BD%AECentOS7%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BD%BF%E7%94%A8%E9%9D%99%E6%80%81IP%E4%B8%8A%E7%BD%91/</url>
    <content><![CDATA[<p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;</p>
<p>&emsp;&emsp;<strong>最近在VMware虚拟机里玩Centos，装好后发现上不了网。经过一番艰辛的折腾，终于找到出解决问题的方法了。最终的效果是无论是ping内网IP还是ping外网ip，都能正常ping通。方法四步走：</strong></p>
<h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>我们进入/etc/sysconfig/network-scripts目录，查看该目录有没有形如<font color=red>ifcfg-XXX</font>的文件：<br><img src="https://img-blog.csdnimg.cn/20200827003203399.png#pic_center" alt=""><br>&emsp;&emsp;如果你看不到以<font color=red>ifcfg-</font>打头的文件（ifcfg-lo除外），说明网卡设备没有被正确识别，可能是你下载的centos镜像版本和你安装centos时选择的centos版本不一致，比如，centos镜像是64位的，却按照32位来安装。这个。。重装吧.</p>
<h2 id="第二步："><a href="#第二步：" class="headerlink" title="第二步："></a>第二步：</h2><p>在VMware里，依次点击”编辑“ - ”虚拟网络编辑器“，如下图，我选择的是NAT模式：<br><img src="https://img-blog.csdnimg.cn/20200827003735144.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>&emsp;&emsp;为了能够使用静态IP，这里不要勾选”使用本地DHCP服务将IP分配给虚拟机“这个选项。然后是配置子网ip，子网IP与宿主机的ip一定不能处在同一地址范围里，否则就算虚拟机能上网，网络既慢，还不稳定。我主机的ip段是192.168.115.xxx，所以我配了192.168.10.xxx来避开主机的ip段，反正ip的第三个数字在0到254并且不是115就行。Nat模式相当于配置了一个子路由器，有设置过多级路由的朋友对此应该有所体会。各位结合自己机器的IP来合理配置一个子网ip吧。</p>
<p>&emsp;&emsp;在这个界面接着点”NAT设置”，查看虚拟机的网关，这个网关在第三步要用。我这里的网关是192.168.10.2。</p>
<p><img src="https://img-blog.csdnimg.cn/20200827003831407.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h2 id="第三步："><a href="#第三步：" class="headerlink" title="第三步："></a>第三步：</h2><p>以root权限编辑 <font color=red><strong>vi /etc/sysconfig/network-scripts/ifcfg-eno16777736</strong></font>这个文件，效果如下：</p>
<p>TYPE=Ethernet<br>BOOTPROTO=static <font color=red> #设置静态Ip</font><br>DEFROUTE=yes<br>IPV4_FAILURE_FATAL=no<br>IPV6INIT=yes<br>IPV6_AUTOCONF=yes<br>IPV6_DEFROUTE=yes<br>IPV6_FAILURE_FATAL=no<br>NAME=eno16777736<br>UUID=4f40dedc-031b-4b72-ad4d-ef4721947439<br>DEVICE=eno16777736<br>ONBOOT=yes  <font color=red>#这里如果为no的话就改为yes，表示网卡设备自动启动</font><br>PEERDNS=yes<br>PEERROUTES=yes<br>IPV6_PEERDNS=yes<br>IPV6_PEERROUTES=yes<br>IPV6_PRIVACY=no</p>
<p>GATEWAY=192.168.10.2 <font color=red> #这里的网关地址就是第二步获取到的那个网关地址</font><br>IPADDR=192.168.10.150 <font color=red> #配置ip，在第二步已经设置ip处于192.168.10.xxx这个范围，我就随便设为150了，只要不和网关相同均可</font><br>NETMASK=255.255.255.0<font color=red>#子网掩码</font><br>DNS1=202.96.128.86<font color=red>#dns服务器1，填写你所在的网络可用的dns服务器地址即可</font><br>DNS2=223.5.5.5<font color=red>#dns服器2</font></p>
<p>关键的参数我都用彩色底纹标记出来了，其他的保持默认就好，确认无误后保存退出。</p>
<h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p>重启网卡服务，执行service network restart，然后总算能上网了：</p>
<p>ping下百度的域名</p>
<p><img src="https://img-blog.csdnimg.cn/20200827004327947.png#pic_center" alt=""></p>
<p><img src="https://img-blog.csdnimg.cn/20200827004200264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<p>如果主机ping不通虚拟机，可将主机中网络连接VMware Virtual Ethernet Adapter for VMnet8的ip设置成和虚拟机ip同一网段的，默认网关留空</p>
<p><img src="https://img-blog.csdnimg.cn/20200827004404903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<h2 id="第五步"><a href="#第五步" class="headerlink" title="第五步"></a>第五步</h2><p><strong>如果出现Xshell链接错误：Could notconnect to ‘192.168.18.128’ (port 22): Connection failed.</strong></p>
<p><img src="https://img-blog.csdnimg.cn/20200827004610248.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""><br><font color=red>这个问题一般是你 的什么配置影响了虚拟机的网卡网关设置！！！。</font></p>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>　　网上的那些解决方案，我都试过，比如。</p>
<blockquote>
<p><a href="http://blog.csdn.net/fengasdfgh/article/details/60135290" target="_blank" rel="noopener">http://blog.csdn.net/fengasdfgh/article/details/60135290</a></p>
</blockquote>
<p>　　什么，关闭防火墙、重启ssh服务等，都不行。</p>
<p>　　给大家，附上这种方法<br><img src="https://img-blog.csdnimg.cn/20200827004840625.png#pic_center" alt=""><br><img src="https://img-blog.csdnimg.cn/20200827004855343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyNDQ2MTU2,size_16,color_FFFFFF,t_70#pic_center" alt=""></p>
<p><img src="https://img-blog.csdnimg.cn/20200827004922696.png#pic_center" alt=""></p>
<p><strong>最后修改之前虚拟机的ip，重复上面步骤即可</strong></p>
]]></content>
      <categories>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
        <tag>CentOS7</tag>
      </tags>
  </entry>
</search>
